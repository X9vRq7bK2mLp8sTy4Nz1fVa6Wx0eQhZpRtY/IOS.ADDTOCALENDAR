<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exams</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
    }
    .spinner {
      border: 4px solid rgba(0, 0, 0, .1);
      border-left-color: #09f;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Styles for sortable table headers */
    .sortable {
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    .sortable:hover {
      background-color: #f1f5f9; /* gray-100 */
    }
    /* Arrows for sorting */
    .sort-arrow {
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      color: #9ca3af; 
    }
    .sortable[data-sort-dir="asc"] .sort-arrow::after {
      content: '▲';
      color: #3b82f6; 
    }
    .sortable[data-sort-dir="desc"] .sort-arrow::after {
      content: '▼';
      color: #3b82f6; 
    }
    
    /* Ensure table content doesn't wrap unnecessarily and allows for horizontal scroll on mobile */
    #results-tbody td {
        white-space: nowrap;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">

  <div class="max-w-4xl mx-auto bg-white p-6 md:p-8 rounded-lg shadow-md">
    <h3 class="text-2xl font-bold text-gray-900 mb-2">Exam Schedules</h3>
    <div class="text-gray-600 text-sm mb-6">
      Enter a student’s name to find all their subjects, dates, venues, and desks.
    </div>

    <label for="query" class="block text-sm font-medium text-gray-700 mt-4 mb-2">Search name</label>
    <input id="query" type="text" placeholder="e.g. Wessels, Joshua or Joshua Wessels"
           class="block w-full max-w-lg border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm p-2.5">

    <button id="run"
            class="mt-6 px-5 py-2.5 bg-blue-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400 flex items-center gap-2">
      Find Matches
    </button>
    
    <div id="status" class="text-gray-600 text-sm mt-4 flex items-center gap-2"></div>
    
    <div id="results-container" class="mt-6 w-full overflow-x-auto">
      <div id="results"></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <script>
    // --- CONFIGURATION ---
    const fileBasePath = '/resources/';
    // RESTORED: Using the TXT file for complete timetable/practical details
    const timetableFile = 'timetable.txt'; 
    const scheduleFiles = [
      'Acc.xlsx',
      'Afr-Drama.xlsx',
      'EGD-IT.xlsx',
      'LO.xlsx',
      'LS-VA.xlsx'
    ];
    
    const timetableMap = new Map();
    let globalResults = [];
    let currentSort = { key: 'dateObj', dir: 'asc' }; 
    
    // --- END CONFIGURATION ---


    // --- SUBJECT NORMALIZATION (CRITICAL FOR PRACTICALS) ---
    // Mapping Excel sheet subjects to their canonical, timetable-friendly names.
    const subjectNormalizationMap = {
      'afri hl': 'afrikaans hl', 'afri eat': 'afrikaans fal', 'afri fal': 'afrikaans fal',
      'eng hl': 'english hl', 'eng fal': 'english fal', 'maths': 'mathematics',
      'maths lit': 'maths lit', 'geo': 'geography', 'it': 'it', 'cat': 'cat',
      'life sciences': 'life sciences', 'physical science': 'physical sc', 'physical sc': 'physical sc',
      'business studies': 'business studies', 'accounting': 'accounting', 'history': 'history',
      'lo': 'life orientation', 'design': 'design', 'drama': 'dramatic arts', 'dramatic arts': 'dramatic arts',
      'music': 'music', 'visual arts': 'visual arts', 'egd': 'egd', 'isixhosa': 'isixhosa hl',
      'isixhosa hl': 'isixhosa hl', 'dramatic arts prac': 'dramatic arts prac', 'visual arts prac': 'visual arts prac',
    };

    /**
     * Creates a consistent, canonical key (Name P# or Name Prac) used for the timetable map lookup.
     * This is the single most critical function for linking the two datasets.
     */
    function normalizeSubject(subject, paper = '') {
      let normSub = subject.toLowerCase()
        .replace(/gr\s*10/i, '').replace(/\n/g, ' ').trim();
      let normPaper = paper.toLowerCase().replace(/[\(\)]/g, '').trim();

      // Step 1: Map to canonical subject name
      const keyBase = subjectNormalizationMap[normSub] || normSub;

      // Step 2: Handle Practical subjects
      if (keyBase.includes('prac') || normPaper.includes('prac')) {
          // Ensure key is standardized: e.g., 'cat prac'
          let pracKey = keyBase.replace(/practical/i, 'prac').replace(/\s*p\d/, '').trim();
          if (!pracKey.endsWith('prac')) pracKey += ' prac';
          return pracKey;
      }
      
      // Special case: Sheets like VA/DA often have no paper listed, but they refer to the main exam.
      if (keyBase === 'visual arts' && normPaper === '') return 'visual arts p1';
      if (keyBase === 'dramatic arts' && normPaper === '') return 'dramatic arts p1';

      // General Case: Subject P1, P2, P3
      return `${keyBase} ${normPaper || 'p1'}`.trim();
    }


    // --- NETWORKING ---
    async function fetchFile(url, type = 'arraybuffer') {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Network error: ${response.statusText} for file ${url}`);
        }
        if (type === 'text') {
          return await response.text();
        }
        return await response.arrayBuffer();
      } catch (error) {
        console.error(error);
        throw error;
      }
    }

    // --- DATE HELPERS (FIXED DATE FORMAT) ---
    const monthMap = { 'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'may': 4, 'jun': 5, 'jul': 6, 'aug': 7, 'sep': 8, 'sept': 8, 'oct': 9, 'nov': 10, 'dec': 11 };
    const monthMapShort = { 10: 'Oct', 11: 'Nov', 12: 'Dec', 1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun', 7: 'Jul', 8: 'Aug', 9: 'Sep' };
    
    /**
     * Converts a date string (e.g., "27/10" or "28 Oct") to a Date object (in 2025).
     */
    const dateStrToObj = (dateStr) => {
        const year = 2025; 
        dateStr = dateStr.toLowerCase().trim();

        if (dateStr.includes('/')) {
            const [day, month] = dateStr.split('/').map(Number);
            return new Date(year, month - 1, day); 
        }
        
        const parts = dateStr.split(/[\s\/]+/);
        const day = parseInt(parts[0], 10);
        const monStr = parts[1].slice(0, 3);
        const month = monthMap[monStr];
        
        if (isNaN(day) || month === undefined) return null;

        return new Date(year, month, day);
    };
    
    /**
     * Converts a Date object to the required "7 Nov" format.
     */
    const formatDateObj = (dateObj) => {
        if (!dateObj) return 'N/A';
        const day = dateObj.getDate();
        const month = dateObj.getMonth() + 1;
        return `${day} ${monthMapShort[month] || ''}`;
    };


    /**
     * Cleans up the duration string and standardizes the format.
     */
    function formatDuration(duration) {
      if (!duration) return 'N/A';
      let clean = duration.trim().toLowerCase();
      clean = clean.replace(/hrss$/, 'hrs').replace(/hr$/, 'hrs');
      clean = clean.replace(/h(r|rs)?/g, ' hr').trim();
      // Ensure '2 hrs' instead of '2hr'
      if (clean.match(/^\d+\s?hr$/)) return clean.replace('hr', 'hrs');
      return clean;
    }

    /**
     * Calculates duration from start/end times in H:MM format.
     */
    function calculateDuration(start, end) {
        if (!start || !end) return 'N/A';
        const startParts = start.split(':').map(Number);
        const endParts = end.split(':').map(Number);
        const startMin = startParts[0] * 60 + startParts[1];
        const endMin = endParts[0] * 60 + endParts[1];
        let diffMin = endMin - startMin;
        
        if (diffMin < 0) diffMin += 1440; // Assume next day for wrap-around (unlikely but safe)
        
        const h = Math.floor(diffMin / 60);
        const m = diffMin % 60;
        
        if (m === 0) return `${h} hrs`;
        if (h === 0) return `${m} mins`;
        return `${h}h${m}`;
    }


    // --- TIMETABLE PARSING (from timetable.txt) ---
    async function parseTimetable() {
      timetableMap.clear();
      const text = await fetchFile(fileBasePath + timetableFile, 'text');
      const lines = text.split('\n');

      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine) continue;

        // Pattern 1: Subject P# (Duration) Start – End Date (most common)
        const match = trimmedLine.match(/^(.*?)\s*(P\d)?\s*(?:\((.*?)\))?\s*(\d{2}:\d{2})\s*[–-]\s*(\d{2}:\d{2})\s*(\d{1,2}\/\d{1,2})$/i);

        // Pattern 2: Practical with time and explicit label
        const pracMatch = trimmedLine.match(/^(.*?)\s*(Practical|Prac|PRAC)\s*(\d{2}:\d{2})\s*[–-]\s*(\d{2}:\d{2})\s*(\d{1,2}\/\d{1,2})$/i);
        
        // Pattern 3: DA PRAC (special case)
        const daPracMatch = trimmedLine.match(/^(DA PRAC)\s*(\d{2}:\d{2})\s*(\d{1,2}\/\d{1,2})$/i);

        let subject, paper, duration, startTime, endTime, dateStr, key;

        if (match) {
          subject = match[1].trim();
          paper = (match[2] || '').trim();
          startTime = match[4];
          endTime = match[5];
          duration = formatDuration(match[3] || calculateDuration(startTime, endTime));
          dateStr = match[6];
          key = normalizeSubject(subject, paper);

        } else if (pracMatch) {
          // This ensures the practical subject is captured correctly (e.g., 'CAT Practical')
          subject = pracMatch[1].trim() + ' ' + pracMatch[2].trim(); 
          paper = 'Prac';
          startTime = pracMatch[3];
          endTime = pracMatch[4];
          dateStr = pracMatch[5];
          duration = calculateDuration(startTime, endTime);
          key = normalizeSubject(subject, paper);

        } else if (daPracMatch) {
            subject = 'Dramatic Arts Prac'; 
            paper = 'Prac';
            startTime = daPracMatch[2];
            endTime = '14:30'; // Assumed end time 14:30 based on typical practical length
            dateStr = daPracMatch[3];
            duration = calculateDuration(startTime, endTime);
            key = normalizeSubject(subject, paper);

        } else {
          // console.warn('Could not parse timetable line:', trimmedLine);
          continue;
        }

        const dateObj = dateStrToObj(dateStr);
        if (!dateObj) continue;
        
        const formattedDateStr = formatDateObj(dateObj); // Use the required '7 Nov' format
        
        if (!timetableMap.has(key)) {
          timetableMap.set(key, {
            dateStr: formattedDateStr,
            duration: duration,
            startTime: startTime.replace(':', ''), // Store as 0900
            endTime: endTime.replace(':', ''),     // Store as 1200
            dateObj: dateObj,
            originalSubject: subject 
          });
        }
      }
      // console.log('Timetable Map populated with', timetableMap.size, 'entries');
    }


    // --- SCHEDULE PARSING (Finds Venue/Desk) ---
    function parseSchedule(wb, candidates) {
      const venueResults = [];

      for (const sheetName of wb.SheetNames) {
        const sheet = wb.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });
        
        if (data.length < 2) continue;

        let headerRowIndex = 0;
        let header = data[headerRowIndex].map(h => h.toString().trim());
        
        // Find the real header row (the one with Venue/Desk)
        if (!header.some(h => h.match(/venue|desk/i)) && data.length > 1) {
            let header2 = data[1].map(h => h.toString().trim());
            if (header2.some(h => h.match(/venue|desk/i))) {
                headerRowIndex = 1;
                header = header2;
            }
        }

        let subject = (header[0] || '').replace(/GR\s*10/i, '').trim() || sheetName;
        // Clean up subject from header cell if it's above the actual header row
        if (headerRowIndex > 0) {
             let potentialSubject = data[0][0].toString().trim().replace(/GR\s*10/i, '').trim();
             if (potentialSubject && !potentialSubject.match(/venue|desk/i) && potentialSubject.length > 5) {
                subject = potentialSubject;
            }
        }
        
        const venueCols = [];
        header.forEach((h, i) => { if (h.match(/venue/i)) venueCols.push(i); });

        const deskCols = [];
        header.forEach((h, i) => { if (h.match(/desk/i)) deskCols.push(i); });

        const paperCols = [];
        header.forEach((h, i) => {
          const hStr = h.toString().trim();
          // Match P1, P2, P3, or just a column that likely represents a paper/date (e.g., in a single-paper sheet)
          if (hStr.match(/P(\d)/i) || (i > 1 && !hStr.match(/venue|desk/i) && hStr.length > 1) ) {
            let paper = hStr.match(/P(\d)/i) ? 'P' + RegExp.$1 : '';
            
            // Special case for practicals listed in the schedule header (like IT/EGD)
            if (hStr.match(/prac|practical/i) && !paper) {
                paper = 'Prac';
            }
            paperCols.push({ col: i, paper: paper });
          }
        });
        
        // If no paper columns found, assume it's a single-paper sheet (like LO)
        if (paperCols.length === 0 && (venueCols.length > 0 || deskCols.length > 0)) {
            // Add a dummy paper column at the end to force processing
            paperCols.push({ col: header.length, paper: '' });
        } else if (paperCols.length === 0) {
             continue; // No relevant data in this sheet
        }

        let currentValues = new Array(header.length).fill('');
        
        for (let r = headerRowIndex + 1; r < data.length; r++) {
          const row = data[r].map(cell => cell.toString().trim());

          // Apply fill-down logic
          for (let c = 0; c < row.length; c++) {
            if (row[c] !== '') currentValues[c] = row[c];
          }

          // Check if student name is present in the current row's name cells
          const nameCell1 = (row[0] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
          const nameCell2 = (row[1] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();

          let matched = false;
          for (const c of candidates) {
            // Check if candidate name is *contained* in either cell
            if (nameCell1.includes(c) || nameCell2.includes(c)) {
              matched = true;
              break;
            }
          }

          if (!matched) continue;

          // Student matched. Find venue/desk for each paper.
          for (const paperInfo of paperCols) {
            const pc = paperInfo.col;
            
            // Find last venue/desk col *before* this paper col
            let vCol = venueCols.filter(v => v < pc).pop();
            let dCol = deskCols.filter(d => d < pc).pop();

            let venue = (vCol !== undefined ? currentValues[vCol] : '') || 'N/A';
            let desk = (dCol !== undefined ? currentValues[dCol] : '') || 'N/A';
            
            // Handle layouts where venue/desk is *after* paper col (e.g., single-paper sheets)
            if ((venue === 'N/A' || venue === '') && venueCols.length > 0) {
                const vColAfter = venueCols.filter(v => v > pc && v < (pc + 3)).shift(); 
                if (vColAfter !== undefined) venue = currentValues[vColAfter] || 'N/A';
                else if (paperCols.length === 1) venue = currentValues[venueCols[0]] || 'N/A'; // Fallback
            }
            if ((desk === 'N/A' || desk === '') && deskCols.length > 0) {
                const dColAfter = deskCols.filter(d => d > pc && d < (pc + 3)).shift();
                if (dColAfter !== undefined) desk = currentValues[dColAfter] || 'N/A';
                else if (paperCols.length === 1) desk = currentValues[deskCols[0]] || 'N/A'; // Fallback
            }
            
            // Critical check: Ensure venue/desk is not an empty string or 'N/A' if we know the student has the subject
            if (venue !== 'N/A' && venue !== '' && desk !== 'N/A' && desk !== '') {
                 venueResults.push({
                    subject: subject,
                    paper: paperInfo.paper,
                    venue: venue,
                    desk: desk,
                    sheet: sheetName
                });
            }
          }
        }
      }
      return venueResults;
    }

    /**
     * Merges venue results with timetable data, ensuring only exams with a date/time are shown.
     */
    function mergeTimetableData(venueResults) {
      const finalResults = [];
      const seen = new Set();
      
      // Collect all required timetable keys first (subject + P#/Prac)
      const requiredKeys = new Set(venueResults.map(r => normalizeSubject(r.subject, r.paper)));

      // Collect results from the schedule sheets (Venue/Desk)
      for (const r of venueResults) {
        // Creates the normalized key for timetable lookup
        const key = normalizeSubject(r.subject, r.paper);
        const ttEntry = timetableMap.get(key);
        
        if (ttEntry) {
          // Use a unique key to prevent duplicates
          const resultKey = `${key}-${r.venue}-${r.desk}-${ttEntry.dateStr}`;
          if (!seen.has(resultKey)) {
            finalResults.push({
              ...r, // subject, paper, venue, desk, sheet
              ...ttEntry // dateStr (e.g., 7 Nov), duration, startTime, endTime, dateObj
            });
            seen.add(resultKey);
          }
        }
      }
      
      // Add 'orphaned' practicals from the timetable.txt that weren't in the schedule sheets
      // This ensures all practicals are included, even if venue/desk is unknown.
      for (const [key, ttEntry] of timetableMap.entries()) {
          if (key.endsWith('prac') || key.includes('practical')) {
              // Check if a result for this practical already exists (has venue/desk)
              const alreadyIncluded = finalResults.some(r => normalizeSubject(r.subject, r.paper) === key);
              
              // Only add if it's NOT already included AND a paper for that subject was found in the schedules
              // This is a safety check to ensure the student actually takes the subject.
              const baseSubjectKey = key.replace(/ prac$/, ' p1');
              if (!alreadyIncluded && requiredKeys.has(baseSubjectKey)) {
                  finalResults.push({
                      subject: ttEntry.originalSubject,
                      paper: key.endsWith('prac') ? 'Prac' : 'P1',
                      venue: 'Check with Staff',
                      desk: 'N/A',
                      sheet: 'TIMETABLE_FALLBACK',
                      ...ttEntry
                  });
              }
          }
      }

      return finalResults;
    }

    
    // --- UI & EVENT HANDLERS ---
    const runButton = document.getElementById('run');
    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');

    runButton.onclick = async () => {
      const q = (document.getElementById('query').value || '').trim();
      
      statusEl.textContent = '';
      resultsEl.innerHTML = '';
      runButton.disabled = true;
      globalResults = [];

      if (!q) {
        statusEl.textContent = 'Please enter a name to search.';
        runButton.disabled = false;
        return;
      }

      const spinner = document.createElement('div');
      spinner.className = 'spinner';
      statusEl.appendChild(spinner);
      statusEl.appendChild(document.createTextNode(' Initializing...'));

      try {
        // 1. Generate Name Candidates
        const qNorm = q.toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
        const parts = qNorm.split(' ');
        let candidates = [];
        if (parts.length >= 2) {
          const first = parts[0];
          const last = parts.slice(1).join(' ');
          // Add variations: "last first", "first last", "last, first"
          candidates.push((last + ' ' + first).toLowerCase(), (first + ' ' + last).toLowerCase(), (last + ', ' + first).toLowerCase(), (last + ',' + first).toLowerCase());
        } else {
          candidates.push(qNorm);
        }
        candidates = Array.from(new Set(candidates));

        // 2. Fetch and Parse Timetable (from .txt)
        if (timetableMap.size === 0) {
          statusEl.textContent = '';
          statusEl.appendChild(spinner);
          statusEl.appendChild(document.createTextNode(' Loading timetable... (Including Practicals)'));
          
          await parseTimetable();
        }

        // 3. Fetch and Parse Schedules (for venues)
        statusEl.textContent = '';
        statusEl.appendChild(spinner);
        statusEl.appendChild(document.createTextNode(' Searching schedules... (0/' + scheduleFiles.length + ')'));

        let allVenueResults = [];
        for (let i = 0; i < scheduleFiles.length; i++) {
          const fileName = scheduleFiles[i];
          statusEl.textContent = '';
          statusEl.appendChild(spinner);
          statusEl.appendChild(document.createTextNode(` Searching ${fileName}... (${i+1}/${scheduleFiles.length})`));
          
          try {
            const fileAb = await fetchFile(fileBasePath + fileName, 'arraybuffer');
            const fileWb = XLSX.read(fileAb, { type: 'array' });
            const fileResults = parseSchedule(fileWb, candidates);
            allVenueResults = allVenueResults.concat(fileResults);
          } catch (fileError) {
            console.error(`Failed to load or parse ${fileName}:`, fileError);
            // Skip file error and continue
          }
        }

        // 4. Merge Timetable data with Venue data
        statusEl.textContent = '';
        statusEl.appendChild(spinner);
        statusEl.appendChild(document.createTextNode(' Processing results...'));
        
        globalResults = mergeTimetableData(allVenueResults);

        statusEl.textContent = `Found ${globalResults.length} match(es) for "${q}".`;

        if (globalResults.length === 0) {
          resultsEl.innerHTML = '<div class="text-gray-600">No matches found.</div>';
          runButton.disabled = false;
          return;
        }

        // 5. Display Results (sorted by date by default)
        displayResultsTable();
        sortAndDisplayResults('dateObj', 'asc'); 

      } catch (error) {
        console.error('Main process error:', error);
        statusEl.textContent = `An error occurred: ${error.message}`;
      } finally {
        runButton.disabled = false;
        const spinnerEl = statusEl.querySelector('.spinner');
        if (spinnerEl) {
          statusEl.removeChild(spinnerEl);
        }
      }
    };

    /**
     * Renders the table structure (header) and Add to Calendar button.
     */
    function displayResultsTable() {
      resultsEl.innerHTML = ''; 

      const table = document.createElement('table');
      table.id = 'results-table';
      table.className = "min-w-full divide-y divide-gray-200 bg-white rounded-lg shadow-sm border border-gray-200";
      
      const thead = document.createElement('thead');
      thead.className = "bg-gray-50";
      thead.innerHTML = `<tr>
        <th id="sort-subject" class="sortable px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort-key="subject">
          Subject <span class="sort-arrow"></span>
        </th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Paper</th>
        <th id="sort-date" class="sortable px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort-key="dateObj">
          Date <span class="sort-arrow"></span>
        </th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Venue</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Desk</th>
      </tr>`;
      table.appendChild(thead);
      
      const tbody = document.createElement('tbody');
      tbody.id = 'results-tbody';
      tbody.className = "bg-white divide-y divide-gray-200";
      table.appendChild(tbody);
      
      resultsEl.appendChild(table);

      // Add Calendar Button
      const addBtn = document.createElement('button');
      addBtn.id = 'addCal';
      addBtn.textContent = 'Add All to Calendar';
      addBtn.className = "mt-6 px-5 py-2.5 bg-green-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500";
      resultsEl.appendChild(addBtn);

      addBtn.onclick = () => {
        generateICS(globalResults);
      };
      
      // Add Sort Event Listeners
      document.getElementById('sort-date').onclick = () => {
          if (currentSort.key === 'dateObj' && currentSort.dir === 'asc') {
              sortAndDisplayResults('dateObj', 'desc');
          } else if (currentSort.key === 'dateObj' && currentSort.dir === 'desc') {
              sortAndDisplayResults('subject', 'asc'); // secondary sort
          } else {
              sortAndDisplayResults('dateObj', 'asc');
          }
      };
       document.getElementById('sort-subject').onclick = () => {
            const dir = (currentSort.key === 'subject' && currentSort.dir === 'asc') ? 'desc' : 'asc';
            sortAndDisplayResults('subject', dir);
      };
    }
    
    /**
     * Sorts the global results and re-renders the table body.
     */
    function sortAndDisplayResults(sortKey, direction) {
        currentSort = { key: sortKey, dir: direction };
        
        // --- Sorting Logic ---
        globalResults.sort((a, b) => {
            let valA = a[sortKey];
            let valB = b[sortKey];

            if (sortKey === 'dateObj') {
                // Prioritize date first, then subject name if dates are equal
                const dateDiff = (valA ? valA.getTime() : 0) - (valB ? valB.getTime() : 0);
                if (dateDiff !== 0) return direction === 'asc' ? dateDiff : -dateDiff;
                
                // Secondary sort by subject
                valA = String(a.subject).toLowerCase();
                valB = String(b.subject).toLowerCase();

            } else {
                valA = String(valA).toLowerCase();
                valB = String(valB).toLowerCase();
            }

            if (valA < valB) return direction === 'asc' ? -1 : 1;
            if (valA > valB) return direction === 'asc' ? 1 : -1;
            return 0;
        });

        // --- Re-render TBody ---
        const tbody = document.getElementById('results-tbody');
        if (!tbody) return;
        
        tbody.innerHTML = ''; 
        for (const r of globalResults) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
            <td class="px-4 py-3 text-sm text-gray-800 font-medium">${r.subject.replace(/\n/g, ' ')}</td>
            <td class="px-4 py-3 text-sm text-gray-600">${r.paper || '–'}</td>
            <td class="px-4 py-3 text-sm text-gray-600">${r.dateStr}</td>
            <td class="px-4 py-3 text-sm text-gray-600">${r.duration || 'N/A'}</td>
            <td class="px-4 py-3 text-sm text-gray-600">${r.venue}</td>
            <td class="px-4 py-3 text-sm text-gray-600">${r.desk}</td>
            `;
            tbody.appendChild(tr);
        }
        
        // --- Update Header Arrows ---
        document.querySelectorAll('.sortable').forEach(th => th.removeAttribute('data-sort-dir'));
        const activeHeader = document.querySelector(`.sortable[data-sort-key="${sortKey}"]`);
        if (activeHeader) {
            activeHeader.setAttribute('data-sort-dir', direction);
        }
    }


    // --- CALENDAR .ICS GENERATION (WORKING FIX) ---
    function getYYYYMMDD(dateObj) {
      const yyyy = dateObj.getFullYear();
      const mm = (dateObj.getMonth() + 1).toString().padStart(2, '0');
      const dd = dateObj.getDate().toString().padStart(2, '0');
      return `${yyyy}${mm}${dd}`;
    }

    function generateICS(results) {
      const events = [];
      
      const vTimezone = [
        'BEGIN:VTIMEZONE',
        'TZID:Africa/Johannesburg',
        'BEGIN:STANDARD',
        'DTSTART:19700101T000000',
        'TZOFFSETFROM:+0200',
        'TZOFFSETTO:+0200',
        'TZNAME:SAST',
        'END:STANDARD',
        'END:VTIMEZONE'
      ].join('\n');

      for (const r of results) {
        try {
          if (!r.dateObj) continue;

          const ymd = getYYYYMMDD(r.dateObj);
          
          const paperStr = (r.paper && r.paper !== 'P1' && r.paper !== 'Prac') ? `${r.paper} ` : (r.paper === 'Prac' ? 'Prac ' : '');
          const baseUid = `${r.subject.replace(/\s+/g, '')}-${r.paper || 'main'}-${ymd}@exam-schedule.com`;
          
          // Event 1: The Exam Paper (Timed Event)
          const title = `${r.subject.replace(/\n/g, ' ')} ${paperStr}(${r.duration || 'N/A'})`;
          // Escape commas for description/location fields
          const desc = `Venue: ${r.venue}\\nDesk: ${r.desk}`.replace(/,/g, '\\,'); 
          const location = r.venue.replace(/,/g, '\\,');
          
          events.push([
            'BEGIN:VEVENT',
            `UID:${baseUid}-exam`,
            // Use TZID for correct local time handling
            `DTSTART;TZID=Africa/Johannesburg:${ymd}T${r.startTime || '0900'}00`, 
            `DTEND;TZID=Africa/Johannesburg:${ymd}T${r.endTime || '1200'}00`,
            `SUMMARY:${title}`,
            `DESCRIPTION:${desc}`,
            `LOCATION:${location}`,
            'END:VEVENT'
          ].join('\n'));
          
          // Event 2: Venue/Desk Reminder (All-day Event) - Starts on date, ends on next day
          const nextDay = new Date(r.dateObj.getTime() + 86400000);
          const ymdEnd = getYYYYMMDD(nextDay);
          const venueTitle = `Venue: ${r.venue}, Desk: ${r.desk}`;
          const venueDesc = `For ${r.subject.replace(/\n/g, ' ')} ${paperStr}Exam`;
          
          events.push([
            'BEGIN:VEVENT',
            `UID:${baseUid}-venue`,
            `DTSTART;VALUE=DATE:${ymd}`,
            `DTEND;VALUE=DATE:${ymdEnd}`, 
            `SUMMARY:${venueTitle}`,
            `DESCRIPTION:${venueDesc}`,
            `LOCATION:${location}`,
            'END:VEVENT'
          ].join('\n'));

        } catch (e) {
          console.warn("Could not parse event for ICS:", r, e);
        }
      }

      const ics = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//YourApp//ExamScheduler//EN',
        vTimezone,
        ...events,
        'END:VCALENDAR'
      ].join('\n');

      const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'exam_schedule.ics';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

  </script>
</body>
</html>
