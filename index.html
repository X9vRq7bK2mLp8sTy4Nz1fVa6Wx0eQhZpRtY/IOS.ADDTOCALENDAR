<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exams</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
    }
    .spinner {
      border: 4px solid rgba(0, 0, 0, .1);
      border-left-color: #09f;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">

  <div class="max-w-4xl mx-auto bg-white p-6 md:p-8 rounded-lg shadow-md">
    <h3 class="text-2xl font-bold text-gray-900 mb-2">Exam Schedules</h3>
    <div class="text-gray-600 text-sm mb-6">
      Enter a student’s name to find all their subjects, dates, venues, and desks.
    </div>

    <label for="query" class="block text-sm font-medium text-gray-700 mt-4 mb-2">Search name</label>
    <input id="query" type="text" placeholder="e.g. Wessels, Joshua or Joshua Wessels"
           class="block w-full max-w-lg border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm p-2.5">

    <button id="run"
            class="mt-6 px-5 py-2.5 bg-blue-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400 flex items-center gap-2">
      Find Matches
    </button>
    
    <div id="status" class="text-gray-600 text-sm mt-4 flex items-center gap-2"></div>
    <div id="results" class="mt-6"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <script>
    // --- CONFIGURATION ---
    const fileBasePath = '/resources/';
    const timetableFile = 'timetable.txt';
    // Updated file names without spaces
    const scheduleFiles = [
      'Acc.xlsx',
      'Afr-Drama.xlsx',
      'EGD-IT.xlsx',
      'LO.xlsx',
      'LS-VA.xlsx'
    ];
    const timetableMap = new Map();
    const subjectExams = new Map();
    let currentSubjectLine = '';
    // --- END CONFIGURATION ---


    // --- SUBJECT NORMALIZATION ---
    const subjectNormalizationMap = {
      'afri hl': 'afrikaans hl',
      'afri eat': 'afrikaans fal',
      'afri fal': 'afrikaans fal',
      'eng hl': 'english hl',
      'eng fal': 'english fal',
      'maths': 'mathematics',
      'maths lit': 'maths lit',
      'geo': 'geography',
      'it': 'it',
      'cat': 'cat',
      'life sciences': 'life sciences',
      'physical science': 'physical sc',
      'physical sc': 'physical sc',
      'business studies': 'business studies',
      'accounting': 'accounting',
      'history': 'history',
      'lo': 'life orientation',
      'design': 'design',
      'drama': 'dramatic arts',
      'dramatic arts': 'dramatic arts',
      'music': 'music',
      'visual arts': 'visual arts',
      'egd': 'egd',
      'isixhosa': 'isixhosa hl',
      'isixhosa hl': 'isixhosa hl'
    };

    function normalizeSubject(subject) {
      let norm = subject.toLowerCase()
        .replace(/gr\s*10/i, '')
        .replace(/\n/g, ' ')
        .replace(/isixhosa/i, 'isiXhosa')
        .trim();
      
      if (norm.startsWith('physical sc')) return 'physical sc';
      if (norm.startsWith('afri eat')) return 'afrikaans fal';
      if (norm.startsWith('afri hl')) return 'afrikaans hl';
      if (norm.startsWith('eng hl')) return 'english hl';
      if (norm.startsWith('eng fal')) return 'english fal';
      
      return subjectNormalizationMap[norm] || norm;
    }


    // --- NETWORKING ---
    async function fetchFile(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Network error: ${response.statusText} for file ${url}`);
        }
        if (url.endsWith('.txt')) {
          return await response.text();
        } else {
          return await response.arrayBuffer();
        }
      } catch (error) {
        console.error(error);
        throw error;
      }
    }


    // --- TIMETABLE PARSING ---
    async function parseTimetable() {
      timetableMap.clear();
      subjectExams.clear();
      currentSubjectLine = '';

      const text = await fetchFile(fileBasePath + timetableFile);
      const lines = text.split('\n').map(l => l.trim()).filter(l => l);
      let i = 0;

      while (i < lines.length) {
        const line = lines[i];
        const parsedTime = parseTimeLine(line);

        if (parsedTime) {
          let parsedSub;
          let subjectPart = '';

          if (currentSubjectLine) {
            subjectPart = currentSubjectLine;
            currentSubjectLine = '';
          } else {
            // Single line: extract subject part before time
            const timeIndex = line.search(/\d{2}:\d{2}/);
            if (timeIndex > -1) {
              subjectPart = line.substring(0, timeIndex).trim();
            }
          }

          if (subjectPart) {
            parsedSub = parseSubjectLine(subjectPart);

            // Special cases
            if (!parsedSub || !parsedSub.subject) {
              if (subjectPart.toUpperCase() === 'DA PRAC') {
                parsedSub = { subject: 'Dramatic Arts', lang: '', paper: 'Practical', duration: '' };
              } else if (subjectPart === 'VA Practical' || subjectPart === 'Visual Arts Practical') {
                parsedSub = { subject: 'Visual Arts', lang: '', paper: 'Practical', duration: '' };
              } else if (subjectPart === 'Design Practical') {
                parsedSub = { subject: 'Design', lang: '', paper: 'Practical', duration: '' };
              }
            }
          }

          if (parsedSub) {
            let { subject, lang, paper, duration } = parsedSub;
            let { start, end, date } = parsedTime;

            if (!duration && end) {
              duration = calculateDuration(start, end);
            }
            if (!end && duration) {
              end = calculateEnd(start, duration);
            }
            if (!duration && !end) {
              duration = 'N/A';
              end = 'N/A';
            }

            const normSub = normalizeSubject(subject + (lang ? ' ' + lang.toUpperCase() : ''));
            const normPaper = (paper || '').toLowerCase().replace('prac', 'practical');

            const key = `${normSub} ${normPaper}`.trim();

            if (!timetableMap.has(key)) {
              timetableMap.set(key, {
                duration,
                startTime: start,
                endTime: end
              });
            }

            let exams = subjectExams.get(normSub) || [];
            exams.push({
              paper: normPaper || 'P1',
              duration,
              startTime: start,
              endTime: end,
              dateStr: standardizeDateStr(date)
            });
            subjectExams.set(normSub, exams);
          }
        } else {
          // Assume subject line
          currentSubjectLine = line;
        }
        i++;
      }
      console.log('Timetable Map populated:', timetableMap);
      console.log('Subject Exams:', subjectExams);
    }

    function parseSubjectLine(line) {
      line = line.trim();

      // Match with duration
      let match = line.match(/^(.+?)( HL| FAL| HL\/FAL)? (P\d (?:\([Pp]rac\))?|Practical|PRAC)? \(([\d½ ]+ ?hrs?)\)$/i);
      if (match) {
        let paper = match[3] ? match[3].replace(/ \([Pp]rac\)/i, ' Practical') : '';
        return { subject: match[1].trim(), lang: (match[2] || '').trim(), paper: paper.trim(), duration: match[4].trim().replace(/hr(s)?/, 'hrs').replace('hrss', 'hrs') };
      }

      // Match without duration
      match = line.match(/^(.+?)( HL| FAL| HL\/FAL)? (P\d (?:\([Pp]rac\))?|Practical|PRAC|(Prac))?/i);
      if (match) {
        let paper = match[3] ? match[3].replace(/ \([Pp]rac\)/i, ' Practical') : '';
        return { subject: match[1].trim(), lang: (match[2] || '').trim(), paper: paper.trim(), duration: '' };
      }

      return null;
    }

    function parseTimeLine(line) {
      // Full time range
      let match = line.match(/(\d{2}:\d{2})[ –—−]+(\d{2}:\d{2}) (\d{1,2}\/\d{1,2})/);
      if (match) {
        return { start: match[1].replace(':', ''), end: match[2].replace(':', ''), date: match[3] };
      }

      // Start time only
      match = line.match(/(\d{2}:\d{2}) (\d{1,2}\/\d{1,2})/);
      if (match) {
        return { start: match[1].replace(':', ''), end: '', date: match[2] };
      }

      return null;
    }

    function calculateEnd(start, duration) {
      if (!duration) return '';
      const durNum = duration.replace('½', '.5').replace(/[^\d.]/g, '');
      const hours = parseFloat(durNum);
      if (isNaN(hours)) return '';
      const startMin = parseInt(start.slice(0, 2)) * 60 + parseInt(start.slice(2));
      const endMin = startMin + hours * 60;
      const endH = Math.floor(endMin / 60).toString().padStart(2, '0');
      const endM = (endMin % 60).toString().padStart(2, '0');
      return endH + endM;
    }

    function calculateDuration(start, end) {
      const s = parseInt(start.slice(0, 2)) * 60 + parseInt(start.slice(2));
      const e = parseInt(end.slice(0, 2)) * 60 + parseInt(end.slice(2));
      const hours = (e - s) / 60;
      return hours + ' hrs';
    }

    function standardizeDateStr(ds) {
      ds = ds.trim();
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      if (ds.match(/^\d{1,2}\/\d{1,2}$/)) {
        const [d, m] = ds.split('/').map(Number);
        return d + ' ' + monthNames[m - 1];
      } else if (ds.match(/^\d{1,2} [A-Za-z]{3}$/)) {
        return ds.replace(/(\d+) (\w+)/, (m, d, mo) => parseInt(d) + ' ' + mo.charAt(0).toUpperCase() + mo.slice(1).toLowerCase());
      }
      return ds;
    }


    // --- SCHEDULE PARSING (NEW, FIXED LOGIC) ---
    function parseSchedule(wb, candidates) {
      const results = [];

      for (const sheetName of wb.SheetNames) {
        const sheet = wb.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });
        
        if (data.length < 2) continue;

        // --- FIX for Subject Contamination ---
        // Find the *real* header row. It's the first row that contains "Venue" or "Desk".
        let headerRowIndex = 0;
        let header = data[headerRowIndex].map(h => h.toString().trim());
        
        if (!header.some(h => h.match(/venue/i)) && data.length > 1) {
            let header2 = data[1].map(h => h.toString().trim());
            if (header2.some(h => h.match(/venue/i))) {
                headerRowIndex = 1;
                header = header2;
            }
        }

        let subject = (header[0] || '').replace(/GR\s*10/i, '').trim() || sheetName;
        // Handle multi-line subjects in the header cell
        const rawSubjectCell = data[headerRowIndex][0] ? data[headerRowIndex][0].toString() : '';
        if (rawSubjectCell.includes('\n')) {
             subject = rawSubjectCell.split('\n').join(' ').replace(/GR\s*10/i, '').trim();
        }
        
        // Handle subjects that are *above* the main header (like in Acc.xlsx)
        if (headerRowIndex > 0) {
            let potentialSubject = data[0][0].toString().trim();
            if (potentialSubject && !potentialSubject.match(/venue/i) && potentialSubject.length > 5) {
                 subject = potentialSubject.replace(/GR\s*10/i, '').trim();
            }
        }
        // --- END Subject Fix ---
        
        const venueCols = [];
        header.forEach((h, i) => { if (h.match(/venue/i)) venueCols.push(i); });

        const deskCols = [];
        header.forEach((h, i) => { if (h.match(/desk/i)) deskCols.push(i); });

        const dateCols = [];
        header.forEach((h, i) => {
          const hStr = h.toString().trim();
          if (hStr.match(/\d{1,2}[- \/](?:Oct|Nov|Dec|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|\d{1,2})/i)) {
            let paper = hStr.match(/P(\d)/) ? 'P' + RegExp.$1 : '';
            let dateStr = hStr.replace(/P\d/i, '').replace(/-/g, ' ').trim();
            dateStr = standardizeDateStr(dateStr);
            dateCols.push({ col: i, paper, dateStr });
          }
        });

        let currentValues = new Array(header.length).fill('');
        
        // Start looping *after* the header row
        for (let r = headerRowIndex + 1; r < data.length; r++) {
          const row = data[r].map(cell => cell.toString().trim());

          // FIX: Skip only if BOTH potential name columns are empty
          if (!row[0] && !row[1]) continue;

          // Apply fill-down logic
          for (let c = 0; c < row.length; c++) {
            if (row[c] !== '') currentValues[c] = row[c];
          }

          // FIX: Check BOTH name columns
          // We check the *current row* for the name, not the fill-down.
          const nameCell1 = (row[0] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
          const nameCell2 = (row[1] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();

          let matched = false;
          for (const c of candidates) {
            if (nameCell1.includes(c) || nameCell2.includes(c)) {
              matched = true;
              break;
            }
          }

          if (!matched) continue; // Not the student we're looking for

          // --- Student matched. ---
          // FIX: Revert to the SIMPLE logic: Add all papers from the header.
          // This fixes the "insanely inaccurate" bug.
          for (const dateInfo of dateCols) {
            const dc = dateInfo.col;
            
            // Find the *last* "Venue" and "Desk" columns *before* this date column
            const vCol = venueCols.filter(v => v < dc).pop();
            const dCol = deskCols.filter(d => d < dc).pop();

            // Use the FILL-DOWN values for venue and desk
            let venue = (vCol !== undefined ? currentValues[vCol] : '') || 'N/A';
            let desk = (dCol !== undefined ? currentValues[dCol] : '') || 'N/A';
            
            // Handle layouts like "GR 10 CAT",Venue,"P1",Venue,Desk,"P2"
            // If venue/desk is blank, check for one *after* this paper column
            if (venue === 'N/A' || venue === '') {
                const vColAfter = venueCols.filter(v => v > dc && v < (dateInfo.col + 3)).shift(); 
                if (vColAfter !== undefined) {
                    venue = currentValues[vColAfter] || 'N/A';
                }
            }
            if (desk === 'N/A' || desk === '') {
                const dColAfter = deskCols.filter(d => d > dc && d < (dateInfo.col + 3)).shift();
                if (dColAfter !== undefined) {
                    desk = currentValues[dColAfter] || 'N/A';
                }
            }

            results.push({
              subject, // Subject is now clean
              paper: dateInfo.paper,
              dateStr: dateInfo.dateStr,
              venue: venue,
              desk: desk,
              sheet: sheetName
            });
          }
        }
      }
      return results;
    }


    /**
     * Fills in results with data from the timetableMap.
     */
    function enrichResultsWithTimetable(results) {
      return results.map(r => {
        const normalizedSubject = normalizeSubject(r.subject);
        const paper = (r.paper || 'P1').toLowerCase(); // Default to P1
        const key = `${normalizedSubject} ${paper}`;
        
        const ttEntry = timetableMap.get(key);

        if (ttEntry) {
          r.duration = ttEntry.duration;
          r.startTime = ttEntry.startTime;
          r.endTime = ttEntry.endTime;
        } else if (!r.duration) {
          // Fallback if not found
          r.duration = '2 hrs'; // Default
          r.startTime = '0900';
          r.endTime = '1100';
          console.warn(`No timetable entry found for key: "${key}" (Raw Subject: "${r.subject}", Paper: "${r.paper}")`);
        }
        return r;
      });
    }

    
    // --- UI & EVENT HANDLERS ---
    const runButton = document.getElementById('run');
    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');

    runButton.onclick = async () => {
      const q = (document.getElementById('query').value || '').trim();
      
      statusEl.textContent = '';
      resultsEl.innerHTML = '';
      runButton.disabled = true;

      if (!q) {
        statusEl.textContent = 'Please enter a name to search.';
        runButton.disabled = false;
        return;
      }

      const spinner = document.createElement('div');
      spinner.className = 'spinner';
      statusEl.appendChild(spinner);
      statusEl.appendChild(document.createTextNode(' Initializing...'));

      try {
        // 1. Generate Name Candidates
        const qNorm = q.toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
        const parts = qNorm.split(' ');
        let candidates = [];
        if (parts.length >= 2) {
          const first = parts[0];
          const last = parts.slice(1).join(' ');
          candidates.push((last + ' ' + first).toLowerCase(), (first + ' ' + last).toLowerCase(), (last + ', ' + first).toLowerCase(), (last + ',' + first).toLowerCase());
        } else {
          candidates.push(qNorm);
        }
        candidates = Array.from(new Set(candidates));

        // 2. Fetch and Parse Timetable
        if (timetableMap.size === 0) {
          statusEl.textContent = '';
          statusEl.appendChild(spinner);
          statusEl.appendChild(document.createTextNode(' Loading timetable...'));
          
          await parseTimetable();
        }

        // 3. Fetch and Parse Schedules
        statusEl.textContent = '';
        statusEl.appendChild(spinner);
        statusEl.appendChild(document.createTextNode(' Searching schedules... (0/' + scheduleFiles.length + ')'));

        let allResults = [];
        for (let i = 0; i < scheduleFiles.length; i++) {
          const fileName = scheduleFiles[i];
          statusEl.textContent = '';
          statusEl.appendChild(spinner);
          statusEl.appendChild(document.createTextNode(` Searching ${fileName}... (${i+1}/${scheduleFiles.length})`));
          
          try {
            const fileAb = await fetchFile(fileBasePath + fileName);
            const fileWb = XLSX.read(fileAb, { type: 'array' });
            const fileResults = parseSchedule(fileWb, candidates);
            allResults = allResults.concat(fileResults);
          } catch (fileError) {
            console.error(`Failed to load or parse ${fileName}:`, fileError);
            statusEl.textContent = `Error: Could not load ${fileName}. Skipping.`;
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }

        // 3.1 Add missing practicals and other exams from timetable
        const studentSubjects = new Set(allResults.map(r => normalizeSubject(r.subject)));

        const subjectVenues = new Map();
        for (const r of allResults) {
          const norm = normalizeSubject(r.subject);
          if (!subjectVenues.has(norm)) {
            subjectVenues.set(norm, { venue: r.venue, desk: r.desk });
          }
        }

        for (const sub of studentSubjects) {
          const exams = subjectExams.get(sub) || [];
          for (const exam of exams) {
            const exists = allResults.some(
              r =>
                normalizeSubject(r.subject) === sub &&
                (r.paper || '').toLowerCase() === exam.paper &&
                r.dateStr === exam.dateStr
            );
            if (!exists) {
              const vd = subjectVenues.get(sub) || { venue: 'N/A', desk: 'N/A' };
              allResults.push({
                subject: sub.charAt(0).toUpperCase() + sub.slice(1), // Capitalize for display
                paper: exam.paper.toUpperCase(),
                dateStr: exam.dateStr,
                venue: vd.venue,
                desk: vd.desk,
                sheet: 'timetable.txt',
                duration: exam.duration,
                startTime: exam.startTime,
                endTime: exam.endTime
              });
            }
          }
        }
        
        // 3.5 Remove duplicate results
        const uniqueResults = [];
        const seen = new Set();
        for (const r of allResults) {
            // A more unique key
            const key = `${normalizeSubject(r.subject)}-${(r.paper || '').toLowerCase()}-${r.dateStr}-${r.venue}-${r.desk}`;
            if (!seen.has(key)) {
                uniqueResults.push(r);
                seen.add(key);
            }
        }

        // 4. Process and Display Results
        statusEl.textContent = '';
        statusEl.appendChild(spinner);
        statusEl.appendChild(document.createTextNode(' Processing results...'));

        const finalResults = enrichResultsWithTimetable(uniqueResults);

        statusEl.textContent = `Found ${finalResults.length} match(es) for "${q}".`;

        if (finalResults.length === 0) {
          resultsEl.innerHTML = '<div class="text-gray-600">No matches found.</div>';
          runButton.disabled = false;
          return;
        }

        displayResultsTable(finalResults);

      } catch (error) {
        console.error('Main process error:', error);
        statusEl.textContent = `An error occurred: ${error.message}`;
      } finally {
        runButton.disabled = false;
        const spinnerEl = statusEl.querySelector('.spinner');
        if (spinnerEl) {
          statusEl.removeChild(spinnerEl);
        }
      }
    };

    /**
     * Renders the results table and "Add to Calendar" button.
     */
    function displayResultsTable(results) {
      const tableContainer = document.createElement('div');
      tableContainer.className = 'overflow-x-auto';

      const table = document.createElement('table');
      table.className = "min-w-full divide-y divide-gray-200 bg-white rounded-lg shadow-sm mt-4 border border-gray-200";
      const thead = document.createElement('thead');
      thead.className = "bg-gray-50";
      thead.innerHTML = `<tr>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Subject</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Paper</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Venue</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Desk</th>
      </tr>`;
      table.appendChild(thead);
      
      const tbody = document.createElement('tbody');
      tbody.className = "bg-white divide-y divide-gray-200";
      for (const r of results) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-800 font-medium">${r.subject.replace(/\n/g, ' ')}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.paper || '–'}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.dateStr}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.duration || 'N/A'}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.venue}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.desk}</td>
        `;
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);

      tableContainer.appendChild(table);
      resultsEl.innerHTML = '';
      resultsEl.appendChild(tableContainer);

      // Sorting functionality
      let sortState = 0; // 0: asc (default), but cycle starts from click
      const dateTh = thead.querySelectorAll('th')[2];
      dateTh.style.cursor = 'pointer';

      // Initial sort: asc by date, no arrow
      sortTable(tbody, 'asc');
      dateTh.innerHTML = 'Date';

      dateTh.onclick = () => {
        sortState = (sortState + 1) % 3;
        const sortType = ['desc', 'asc', 'alpha'][sortState];
        const arrow = sortType === 'desc' ? '&#9660;' : sortType === 'asc' ? '&#9650;' : '';
        dateTh.innerHTML = 'Date ' + arrow;
        sortTable(tbody, sortType);
      };

      const addBtn = document.createElement('button');
      addBtn.id = 'addCal';
      addBtn.textContent = 'Add All to Calendar';
      addBtn.className = "mt-6 px-5 py-2.5 bg-green-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500";
      resultsEl.appendChild(addBtn);

      addBtn.onclick = () => {
        generateICS(results);
      };
    }

    function sortTable(tbody, sortType) {
      const rows = Array.from(tbody.querySelectorAll('tr'));
      rows.sort((a, b) => {
        const da = a.children[2].textContent.trim();
        const db = b.children[2].textContent.trim();
        if (sortType === 'alpha') {
          return da.localeCompare(db);
        } else {
          const dateA = parseDateStr(da);
          const dateB = parseDateStr(db);
          const sign = sortType === 'asc' ? 1 : -1;
          return sign * (dateA - dateB);
        }
      });
      tbody.innerHTML = '';
      rows.forEach(r => tbody.appendChild(r));
    }

    function parseDateStr(ds) {
      const monthMap = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, sept: 8, oct: 9, nov: 10, dec: 11 };
      const [dayStr, monStr] = ds.split(/[ \/]/);
      const day = parseInt(dayStr, 10);
      let mon;
      const monNum = parseInt(monStr, 10);
      if (isNaN(monNum)) {
        mon = monthMap[monStr.toLowerCase().slice(0, 3)] + 1;
      } else {
        mon = monNum;
      }
      return new Date(2025, mon - 1, day).getTime();
    }


    // --- CALENDAR .ICS GENERATION (FIXED & FULL-FEATURED) ---
    function getYYYYMMDD(dateObj) {
      const yyyy = dateObj.getFullYear();
      const mm = (dateObj.getMonth() + 1).toString().padStart(2, '0');
      const dd = dateObj.getDate().toString().padStart(2, '0');
      return `${yyyy}${mm}${dd}`;
    }

    function generateICS(results) {
      const events = [];
      const monthMap = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, sept: 8, oct: 9, nov: 10, dec: 11 };
      
      // Use 2025 as the year, based on timetable filename
      const year = 2025; 

      const vTimezone = [
        'BEGIN:VTIMEZONE',
        'TZID:Africa/Johannesburg',
        'BEGIN:STANDARD',
        'DTSTART:19700101T000000',
        'TZOFFSETFROM:+0200',
        'TZOFFSETTO:+0200',
        'TZNAME:SAST',
        'END:STANDARD',
        'END:VTIMEZONE'
      ].join('\n');

      for (const r of results) {
        try {
          const parts = r.dateStr.toLowerCase().split(/[ \/-]/);
          const day = parseInt(parts[0], 10);
          const monPart = parts[1];
          let month;
          if (/^\d+$/.test(monPart)) {
            month = parseInt(monPart, 10) - 1;
          } else {
            const monStr = monPart.slice(0, 3);
            month = monthMap[monStr];
          }
          
          if (isNaN(day) || month === undefined) {
            console.warn("Skipping event with invalid date string:", r.dateStr);
            continue;
          }
          
          const dateObj = new Date(year, month, day);
          const ymd = getYYYYMMDD(dateObj);
          
          const nextDay = new Date(dateObj.getTime() + 86400000);
          const ymdEnd = getYYYYMMDD(nextDay);
          
          const paperStr = r.paper ? `${r.paper} ` : '';
          const baseUid = `${r.subject.replace(/\s+/g, '')}-${r.paper || 'main'}-${ymd}@exam-schedule.com`;
          
          // --- Event 1: The Exam Paper (Timed Event) ---
          const title = `${r.subject.replace(/\n/g, ' ')} ${paperStr}(${r.duration || 'N/A'})`;
          const desc = `Venue: ${r.venue}\\nDesk: ${r.desk}`.replace(/,/g, '\\,');
          const location = r.venue.replace(/,/g, '\\,');
          
          events.push([
            'BEGIN:VEVENT',
            `UID:${baseUid}-exam`,
            `DTSTART;TZID=Africa/Johannesburg:${ymd}T${r.startTime || '0900'}00`,
            `DTEND;TZID=Africa/Johannesburg:${ymd}T${r.endTime || '1200'}00`,
            `SUMMARY:${title}`,
            `DESCRIPTION:${desc}`,
            `LOCATION:${location}`,
            'END:VEVENT'
          ].join('\n'));
          
          // --- Event 2: Venue/Desk Reminder (All-day Event) ---
          const venueTitle = `Venue: ${r.venue}, Desk: ${r.desk}`;
          const venueDesc = `For ${r.subject.replace(/\n/g, ' ')} ${paperStr}Exam`;
          
          events.push([
            'BEGIN:VEVENT',
            `UID:${baseUid}-venue`,
            `DTSTART;VALUE=DATE:${ymd}`,
            `DTEND;VALUE=DATE:${ymdEnd}`,
            `SUMMARY:${venueTitle}`,
            `DESCRIPTION:${venueDesc}`,
            `LOCATION:${location}`,
            'END:VEVENT'
          ].join('\n'));

        } catch (e) {
          console.warn("Could not parse event:", r, e);
        }
      }

      const ics = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//YourApp//ExamScheduler//EN',
        vTimezone,
        ...events,
        'END:VCALENDAR'
      ].join('\n');

      const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'exam_schedule.ics';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

  </script>
</body>
</html>
