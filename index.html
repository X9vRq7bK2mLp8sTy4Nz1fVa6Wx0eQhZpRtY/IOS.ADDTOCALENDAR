<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exams</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
    }
    .spinner {
      border: 4px solid rgba(0, 0, 0, .1);
      border-left-color: #09f;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">
  <div class="max-w-4xl mx-auto bg-white p-6 md:p-8 rounded-lg shadow-md">
    <h3 class="text-2xl font-bold text-gray-900 mb-2">Exam Schedules</h3>
    <div class="text-gray-600 text-sm mb-6">
      Enter a student’s name to find all their subjects, dates, venues, and desks.
    </div>
    <label for="query" class="block text-sm font-medium text-gray-700 mt-4 mb-2">Search name</label>
    <input id="query" type="text" placeholder="e.g. Wessels, Joshua or Joshua Wessels"
           class="block w-full max-w-lg border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm p-2.5">
    <button id="run"
            class="mt-6 px-5 py-2.5 bg-blue-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400 flex items-center gap-2">
      Find Matches
    </button>
    <div id="status" class="text-gray-600 text-sm mt-4 flex items-center gap-2"></div>
    <div id="results" class="mt-6"></div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script>
    // --- CONFIGURATION ---
    const fileBasePath = '/resources/';
    const timetableFile = 'timetable.txt';
    const scheduleFiles = ['Acc.xlsx', 'Afr-Drama.xlsx', 'EGD-IT.xlsx', 'LO.xlsx', 'LS-VA.xlsx'];
    const timetableMap = new Map();
    const subjectNormalizationMap = {
      'afri hl': 'afrikaans hl',
      'afri eat': 'afrikaans fal',
      'afri fal': 'afrikaans fal',
      'eng hl': 'english hl',
      'eng fal': 'english fal',
      'maths': 'mathematics',
      'maths lit': 'maths lit',
      'geo': 'geography',
      'it': 'it',
      'cat': 'cat',
      'life sciences': 'life sciences',
      'physical science': 'physical sc',
      'business studies': 'business studies',
      'accounting': 'accounting',
      'history': 'history',
      'lo': 'life orientation',
      'design': 'design',
      'drama': 'dramatic arts',
      'music': 'music',
      'visual arts': 'visual arts',
      'egd': 'egd',
      'isixhosa': 'isixhosa hl'
    };

    // Derive valid subjects from timetable.txt and normalization map
    const validSubjects = [
      'english hl', 'english fal', 'afrikaans hl', 'afrikaans fal', 'isixhosa hl', 'history',
      'va practical', 'accounting', 'mathematics', 'maths lit', 'business studies', 'physical sc',
      'cat', 'life orientation', 'geography', 'egd', 'design', 'dramatic arts', 'music', 'visual arts',
      'it', 'life sciences', 'design practical', 'visual arts practical', 'da prac'
    ].concat(Object.values(subjectNormalizationMap)).map(s => s.toLowerCase());

    /**
     * Normalizes a subject name for matching.
     * @param {string} subject - The raw subject name.
     * @returns {string} - The normalized name.
     */
    function normalizeSubject(subject) {
      let norm = subject.toLowerCase()
        .replace(/gr\s*10/i, '')
        .replace(/\n/g, ' ')
        .replace(/isixhosa/i, 'isixhosa')
        .replace(/\.xlsx$/i, '')
        .trim();
      return subjectNormalizationMap[norm] || norm;
    }

    /**
     * Fetches a file from the server.
     * @param {string} url - The URL of the file.
     * @returns {Promise<ArrayBuffer|string>} - The file's ArrayBuffer or text.
     */
    async function fetchFile(url, isText = false) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          let errorDetails = '';
          try { errorDetails = ` (Response: ${await response.text().substring(0, 200)}...)`; } catch {}
          throw new Error(`Network error ${response.status}: ${response.statusText} for ${url}${errorDetails}`);
        }
        return isText ? await response.text() : await response.arrayBuffer();
      } catch (error) {
        console.error(`Fetch error for ${url}:`, error);
        throw error;
      }
    }

    /**
     * Parses timetable.txt to populate timetableMap.
     * @param {string} text - The content of timetable.txt.
     */
    function parseTimetable(text) {
      timetableMap.clear();
      const lines = text.split('\n').map(line => line.trim());
      for (let i = 0; i < lines.length - 1; i += 2) {
        const examLine = lines[i];
        const timeLine = lines[i + 1];
        if (!examLine || !timeLine) continue;

        const examMatch = examLine.match(/^(.*?)\s*(P\d)?\s*\((.*?)\)$/i) || examLine.match(/^(.*?)\s*$/i);
        const timeMatch = timeLine.match(/(\d{2}):(\d{2})\s*[–-]\s*(\d{2}):(\d{2})/);
        if (!examMatch || !timeMatch) {
          console.warn(`Skipping invalid timetable entry: ${examLine} / ${timeLine}`);
          continue;
        }

        const subject = examMatch[1].trim();
        const paper = (examMatch[2] || 'P1').trim();
        const duration = examMatch[3] ? examMatch[3].trim() : 'N/A';
        const startTime = `${timeMatch[1]}${timeMatch[2]}`;
        const endTime = `${timeMatch[3]}${timeMatch[4]}`;
        const key = `${normalizeSubject(subject)} ${paper.toLowerCase()}`;
        if (!timetableMap.has(key)) {
          timetableMap.set(key, { duration, startTime, endTime });
        }
      }
      console.log('Timetable Map populated:', timetableMap);
    }

    /**
     * Parses a single schedule workbook to find matches for the given student.
     * @param {object} wb - The XLSX workbook object.
     * @param {Array<string>} candidates - The list of name candidates to search for.
     * @returns {Array<object>} - An array of result objects.
     */
    function parseSchedule(wb, candidates) {
      const results = [];
      for (const sheetName of wb.SheetNames) {
        const sheet = wb.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });
        if (data.length < 2) {
          console.warn(`Sheet ${sheetName} is empty or too short. Skipping.`);
          continue;
        }

        const header = data[0].map(h => h.toString().trim());
        let subject = normalizeSubject(sheetName.replace(/\.xlsx$/i, ''));

        // Validate subject
        if (!validSubjects.includes(subject.toLowerCase())) {
          subject = normalizeSubject(header[0].replace(/GR\s*10/i, '').trim() || sheetName);
          if (data[1] && data[1][0] && header[0].toLowerCase().includes('gr 10') && !data[1][0].toLowerCase().includes('venue')) {
            subject = normalizeSubject(data[1][0].toString().trim().replace(/GR\s*10/i, '').trim());
          }
          if (!validSubjects.includes(subject.toLowerCase())) {
            console.warn(`Invalid subject "${subject}" in sheet ${sheetName}. Skipping sheet.`);
            continue;
          }
        }

        const venueCols = [];
        header.forEach((h, i) => { if (h.match(/venue/i)) venueCols.push(i); });
        const deskCols = [];
        header.forEach((h, i) => { if (h.match(/desk/i)) deskCols.push(i); });
        const dateCols = [];
        header.forEach((h, i) => {
          const hStr = h.toString().trim();
          if (hStr.match(/\d{1,2}[- \/](?:Oct|Nov|Dec|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep)/i)) {
            let paper = hStr.match(/P(\d)/) ? 'P' + RegExp.$1 : '';
            let dateStr = hStr.replace(/P\d/i, '').replace(/-/g, ' ').trim();
            dateCols.push({ col: i, paper, dateStr });
          }
        });

        let currentValues = new Array(header.length).fill('');
        for (let r = 1; r < data.length; r++) {
          const row = data[r].map(cell => cell.toString().trim());
          if (!row[0] && !row[1]) continue;
          for (let c = 0; c < row.length; c++) {
            if (row[c] !== '') currentValues[c] = row[c];
          }

          const nameCell1 = (row[0] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
          const nameCell2 = (row[1] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
          let matched = false;
          for (const c of candidates) {
            if (nameCell1.includes(c) || nameCell2.includes(c)) {
              matched = true;
              break;
            }
          }
          if (!matched) continue;

          for (const dateInfo of dateCols) {
            const dc = dateInfo.col;
            const vCol = venueCols.filter(v => v < dc).pop();
            const dCol = deskCols.filter(d => d < dc).pop();
            const venue = (vCol !== undefined ? currentValues[vCol] : '') || 'N/A';
            const desk = (dCol !== undefined ? currentValues[dCol] : '') || 'N/A';
            const hasDataForPaper = row[dc] || (vCol !== undefined && dCol !== undefined);
            if (hasDataForPaper) {
              results.push({
                subject,
                paper: dateInfo.paper,
                dateStr: dateInfo.dateStr,
                venue,
                desk,
                sheet: sheetName
              });
            }
          }
        }
      }
      return results;
    }

    /**
     * Fills in results with data from timetableMap.
     * @param {Array<object>} results - The array of found exam results.
     */
    function enrichResultsWithTimetable(results) {
      return results.map(r => {
        const normalizedSubject = normalizeSubject(r.subject);
        const paper = (r.paper || 'P1').toLowerCase();
        const key = `${normalizedSubject} ${paper}`;
        const ttEntry = timetableMap.get(key);
        if (ttEntry) {
          r.duration = ttEntry.duration;
          r.startTime = ttEntry.startTime;
          r.endTime = ttEntry.endTime;
        } else {
          r.duration = '3 hrs';
          r.startTime = '0900';
          r.endTime = '1200';
          console.warn(`No timetable entry for "${key}" (Raw: "${r.subject}", Paper: "${r.paper}")`);
        }
        return r;
      });
    }

    const runButton = document.getElementById('run');
    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');

    runButton.onclick = async () => {
      const q = (document.getElementById('query').value || '').trim();
      statusEl.textContent = '';
      resultsEl.innerHTML = '';
      runButton.disabled = true;

      if (!q) {
        statusEl.textContent = 'Please enter a name to search.';
        runButton.disabled = false;
        return;
      }

      const spinner = document.createElement('div');
      spinner.className = 'spinner';
      statusEl.appendChild(spinner);
      statusEl.appendChild(document.createTextNode(' Initializing...'));

      try {
        // --- 1. Generate Name Candidates ---
        const qNorm = q.toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
        const parts = qNorm.split(' ');
        let candidates = [];
        if (parts.length >= 2) {
          const first = parts[0];
          const last = parts.slice(1).join(' ');
          candidates.push((last + ' ' + first).toLowerCase(), (first + ' ' + last).toLowerCase(), (last + ', ' + first).toLowerCase(), (last + ',' + first).toLowerCase());
        } else {
          candidates.push(qNorm);
        }
        candidates = Array.from(new Set(candidates));

        // --- 2. Fetch and Parse Timetable ---
        if (timetableMap.size === 0) {
          statusEl.textContent = '';
          statusEl.appendChild(spinner);
          statusEl.appendChild(document.createTextNode(' Loading timetable...'));
          try {
            const timetableText = await fetchFile(fileBasePath + timetableFile, true);
            parseTimetable(timetableText);
          } catch (ttError) {
            statusEl.textContent = `Error loading timetable: ${ttError.message}. Using defaults.`;
            console.error('Timetable error:', ttError);
          }
        }

        // --- 3. Fetch and Parse Schedules ---
        statusEl.textContent = '';
        statusEl.appendChild(spinner);
        statusEl.appendChild(document.createTextNode(' Searching schedules... (0/' + scheduleFiles.length + ')'));
        let allResults = [];
        for (let i = 0; i < scheduleFiles.length; i++) {
          const fileName = scheduleFiles[i];
          statusEl.textContent = '';
          statusEl.appendChild(spinner);
          statusEl.appendChild(document.createTextNode(` Searching ${fileName}... (${i+1}/${scheduleFiles.length})`));
          try {
            const fileAb = await fetchFile(fileBasePath + fileName);
            const fileWb = XLSX.read(fileAb, { type: 'array' });
            const fileResults = parseSchedule(fileWb, candidates);
            allResults = allResults.concat(fileResults);
          } catch (fileError) {
            console.error(`Failed to load ${fileName}:`, fileError);
            statusEl.textContent = `Error: Could not load ${fileName}: ${fileError.message}. Skipping.`;
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }

        // --- 4. Process and Display Results ---
        statusEl.textContent = '';
        statusEl.appendChild(spinner);
        statusEl.appendChild(document.createTextNode(' Processing results...'));
        const finalResults = enrichResultsWithTimetable(allResults);
        statusEl.textContent = `Found ${finalResults.length} match(es) for "${q}".`;

        if (finalResults.length === 0) {
          resultsEl.innerHTML = '<div class="text-gray-600">No matches found.</div>';
          runButton.disabled = false;
          return;
        }

        displayResultsTable(finalResults);
      } catch (error) {
        console.error('Main process error:', error);
        statusEl.textContent = `An error occurred: ${error.message}`;
      } finally {
        runButton.disabled = false;
        const spinnerEl = statusEl.querySelector('.spinner');
        if (spinnerEl) statusEl.removeChild(spinnerEl);
      }
    };

    /**
     * Renders the results table and "Add to Calendar" button.
     * @param {Array<object>} results - The final array of enriched results.
     */
    function displayResultsTable(results) {
      const table = document.createElement('table');
      table.className = "min-w-full divide-y divide-gray-200 bg-white rounded-lg shadow-sm mt-4 border border-gray-200";
      const thead = document.createElement('thead');
      thead.className = "bg-gray-50";
      thead.innerHTML = `<tr>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Subject</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Paper</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Venue</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Desk</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Sheet</th>
      </tr>`;
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      tbody.className = "bg-white divide-y divide-gray-200";
      for (const r of results) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-800 font-medium">${r.subject.replace(/\n/g, ' ')}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.paper || '–'}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.dateStr}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.duration || 'N/A'}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.venue}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.desk}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-400">${r.sheet}</td>
        `;
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      resultsEl.innerHTML = '';
      resultsEl.appendChild(table);
      const addBtn = document.createElement('button');
      addBtn.id = 'addCal';
      addBtn.textContent = 'Add All to Calendar';
      addBtn.className = "mt-6 px-5 py-2.5 bg-green-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500";
      resultsEl.appendChild(addBtn);
      addBtn.onclick = () => generateICS(results);
    }

    /**
     * Helper to format a date object as YYYYMMDD.
     * @param {Date} dateObj - The date to format.
     * @returns {string} - Formatted string "YYYYMMDD".
     */
    function getYYYYMMDD(dateObj) {
      const yyyy = dateObj.getFullYear();
      const mm = (dateObj.getMonth() + 1).toString().padStart(2, '0');
      const dd = dateObj.getDate().toString().padStart(2, '0');
      return `${yyyy}${mm}${dd}`;
    }

    /**
     * Generates and triggers download of the .ics file.
     * @param {Array<object>} results - The enriched results array.
     */
    function generateICS(results) {
      const events = [];
      const monthMap = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, sept: 8, oct: 9, nov: 10, dec: 11 };
      const currentYear = new Date().getFullYear();
      const currentMonth = new Date().getMonth();
      const vTimezone = [
        'BEGIN:VTIMEZONE',
        'TZID:Africa/Johannesburg',
        'BEGIN:STANDARD',
        'DTSTART:19700101T000000',
        'TZOFFSETFROM:+0200',
        'TZOFFSETTO:+0200',
        'TZNAME:SAST',
        'END:STANDARD',
        'END:VTIMEZONE'
      ].join('\n');

      for (const r of results) {
        try {
          const parts = r.dateStr.toLowerCase().split(/[\s\/]+/);
          const day = parseInt(parts[0], 10);
          const monStr = parts[1].slice(0, 3);
          const month = monthMap[monStr];
          if (isNaN(day) || month === undefined) {
            console.warn("Skipping event with invalid date string:", r.dateStr);
            continue;
          }
          const year = (month < currentMonth) ? currentYear + 1 : currentYear;
          const dateObj = new Date(year, month, day);
          const ymd = getYYYYMMDD(dateObj);
          const nextDay = new Date(dateObj.getTime() + 86400000);
          const ymdEnd = getYYYYMMDD(nextDay);
          const paperStr = r.paper ? `${r.paper} ` : '';
          const baseUid = `${r.subject.replace(/\s+/g, '')}-${r.paper || 'main'}-${ymd}@exam-schedule.com`;
          const title = `${r.subject.replace(/\n/g, ' ')} ${paperStr}(${r.duration || 'N/A'})`;
          const desc = `Venue: ${r.venue}\\nDesk: ${r.desk}`.replace(/,/g, '\\,');
          const location = r.venue.replace(/,/g, '\\,');
          events.push([
            'BEGIN:VEVENT',
            `UID:${baseUid}-exam`,
            `DTSTART;TZID=Africa/Johannesburg:${ymd}T${r.startTime || '0900'}00`,
            `DTEND;TZID=Africa/Johannesburg:${ymd}T${r.endTime || '1200'}00`,
            `SUMMARY:${title}`,
            `DESCRIPTION:${desc}`,
            `LOCATION:${location}`,
            'END:VEVENT'
          ].join('\n'));
          const venueTitle = `Venue: ${r.venue}, Desk: ${r.desk}`;
          const venueDesc = `For ${r.subject.replace(/\n/g, ' ')} ${paperStr}Exam`;
          events.push([
            'BEGIN:VEVENT',
            `UID:${baseUid}-venue`,
            `DTSTART;VALUE=DATE:${ymd}`,
            `DTEND;VALUE=DATE:${ymdEnd}`,
            `SUMMARY:${venueTitle}`,
            `DESCRIPTION:${venueDesc}`,
            `LOCATION:${location}`,
            'END:VEVENT'
          ].join('\n'));
        } catch (e) {
          console.warn("Could not parse event:", r, e);
        }
      }
      const ics = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//YourApp//ExamScheduler//EN',
        vTimezone,
        ...events,
        'END:VCALENDAR'
      ].join('\n');
      const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'exam_schedule.ics';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };
  </script>
</body>
</html>
