<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exams</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
    }
    .spinner {
      border: 4px solid rgba(0, 0, 0, .1);
      border-left-color: #09f;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">

  <div class="max-w-4xl mx-auto bg-white p-6 md:p-8 rounded-lg shadow-md">
    <h3 class="text-2xl font-bold text-gray-900 mb-2">Exam Schedules</h3>
    <div class="text-gray-600 text-sm mb-6">
      Enter a student’s name to find all their subjects, dates, venues, and desks.
    </div>

    <label for="query" class="block text-sm font-medium text-gray-700 mt-4 mb-2">Search name</label>
    <input id="query" type="text" placeholder="e.g. Wessels, Joshua or Joshua Wessels"
           class="block w-full max-w-lg border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm p-2.5">

    <button id="run"
            class="mt-6 px-5 py-2.5 bg-blue-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400 flex items-center gap-2">
      Find Matches
    </button>
    
    <div id="status" class="text-gray-600 text-sm mt-4 flex items-center gap-2"></div>
    <div id="results" class="mt-6"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <script>
    // --- CONFIGURATION ---
    const fileBasePath = '/resources/';
    const timetableFile = 'timetable.xlsx';
    // Updated file names without spaces
    const scheduleFiles = [
      'Acc.xlsx',
      'Afr-Drama.xlsx',
      'EGD-IT.xlsx',
      'LO.xlsx',
      'LS-VA.xlsx'
    ];
    const timetableMap = new Map();
    // --- END CONFIGURATION ---


    // --- SUBJECT NORMALIZATION ---
    const subjectNormalizationMap = {
      'afri hl': 'afrikaans hl',
      'afri eat': 'afrikaans fal',
      'afri fal': 'afrikaans fal',
      'eng hl': 'english hl',
      'eng fal': 'english fal',
      'maths': 'mathematics',
      'maths lit': 'maths lit',
      'geo': 'geography',
      'it': 'it',
      'cat': 'cat',
      'life sciences': 'life sciences',
      'physical science': 'physical sc',
      'physical sc': 'physical sc', // Handle variations
      'business studies': 'business studies',
      'accounting': 'accounting',
      'history': 'history',
      'lo': 'life orientation',
      'design': 'design',
      'drama': 'dramatic arts',
      'dramatic arts': 'dramatic arts', // Handle variations
      'music': 'music',
      'visual arts': 'visual arts',
      'egd': 'egd',
      'isixhosa': 'isixhosa hl',
      'isixhosa hl': 'isixhosa hl' // Handle variations
    };

    function normalizeSubject(subject) {
      let norm = subject.toLowerCase()
        .replace(/gr\s*10/i, '')
        .replace(/\n/g, ' ')
        .replace(/isixhosa/i, 'isiXhosa')
        .trim();
      
      if (norm.startsWith('physical sc')) return 'physical sc';
      if (norm.startsWith('afri eat')) return 'afrikaans fal';
      if (norm.startsWith('afri hl')) return 'afrikaans hl';
      if (norm.startsWith('eng hl')) return 'english hl';
      if (norm.startsWith('eng fal')) return 'english fal';
      
      return subjectNormalizationMap[norm] || norm;
    }


    // --- NETWORKING ---
    async function fetchFile(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Network error: ${response.statusText} for file ${url}`);
        }
        return await response.arrayBuffer();
      } catch (error) {
        console.error(error);
        throw error;
      }
    }


    // --- TIMETABLE PARSING ---
    function parseTimetable(wb) {
      timetableMap.clear();

      for (const sheetName of wb.SheetNames) {
        const sheet = wb.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });

        if (data.length < 2) continue;

        let gr10ColIndex = -1;
        // Check first two rows for header
        const possibleHeaders = [data[0], data[1]]; 

        for (const headerRow of possibleHeaders) {
          if (headerRow) {
            for (let i = 0; i < headerRow.length; i++) {
              if (headerRow[i].toString().trim().toLowerCase() === 'gr 10') {
                gr10ColIndex = i;
                break;
              }
            }
          }
          if (gr10ColIndex !== -1) break;
        }
        
        if (gr10ColIndex === -1) {
          console.warn(`Could not find 'Gr 10' column in timetable sheet '${sheetName}'.`);
          continue; 
        }

        // Start from row 2 (index 2), assuming headers are row 0 or 1
        for (let r = 2; r < data.length; r++) { 
          const row = data[r];
          if (!row || !row[gr10ColIndex]) continue;
          
          const gr10Cell = row[gr10ColIndex].toString();
          if (!gr10Cell) continue;

          const exams = gr10Cell.split('\n');
          let currentSubject = '', currentPaper = '', currentDuration = '', currentStartTime = '', currentEndTime = '';

          for (const line of exams) {
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            const examMatch = trimmedLine.match(/^(.*?)\s*(P\d)?\s*\((.*?hrs?)\)$/i);
            const simpleExamMatch = trimmedLine.match(/^(.*?)\s*\((.*?hrs?)\)$/i);
            const timeMatch = trimmedLine.match(/(\d{2}):(\d{2})\s*[–-]\s*(\d{2}):(\d{2})/);

            if (examMatch) {
              currentSubject = examMatch[1].trim();
              currentPaper = (examMatch[2] || 'P1').trim();
              currentDuration = examMatch[3].trim().replace('hr', 'hrs');
            } else if (simpleExamMatch && !timeMatch && !currentSubject) {
              currentSubject = simpleExamMatch[1].trim();
              currentPaper = 'P1';
              currentDuration = simpleExamMatch[2].trim().replace('hr', 'hrs');
            } else if (timeMatch) {
              currentStartTime = `${timeMatch[1]}${timeMatch[2]}`;
              currentEndTime = `${timeMatch[3]}${timeMatch[4]}`;
            }

            if (currentSubject && currentPaper && currentDuration && currentStartTime) {
              const key = `${currentSubject.toLowerCase()} ${currentPaper.toLowerCase()}`;
              if (!timetableMap.has(key)) {
                timetableMap.set(key, {
                  duration: currentDuration,
                  startTime: currentStartTime,
                  endTime: currentEndTime
                });
              }
              currentSubject = ''; currentPaper = ''; currentDuration = ''; currentStartTime = ''; currentEndTime = '';
            }
          }
        }
      }
      console.log('Timetable Map populated:', timetableMap);
    }


    // --- SCHEDULE PARSING (NEW, FIXED LOGIC) ---
    function parseSchedule(wb, candidates) {
      const results = [];

      for (const sheetName of wb.SheetNames) {
        const sheet = wb.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });
        
        if (data.length < 2) continue;

        // --- FIX for Subject Contamination ---
        // Find the *real* header row. It's the first row that contains "Venue" or "Desk".
        let headerRowIndex = 0;
        let header = data[headerRowIndex].map(h => h.toString().trim());
        
        if (!header.some(h => h.match(/venue/i)) && data.length > 1) {
            let header2 = data[1].map(h => h.toString().trim());
            if (header2.some(h => h.match(/venue/i))) {
                headerRowIndex = 1;
                header = header2;
            }
        }

        let subject = (header[0] || '').replace(/GR\s*10/i, '').trim() || sheetName;
        // Handle multi-line subjects in the header cell
        const rawSubjectCell = data[headerRowIndex][0] ? data[headerRowIndex][0].toString() : '';
        if (rawSubjectCell.includes('\n')) {
             subject = rawSubjectCell.split('\n').join(' ').replace(/GR\s*10/i, '').trim();
        }
        
        // Handle subjects that are *above* the main header (like in Acc.xlsx)
        if (headerRowIndex > 0) {
            let potentialSubject = data[0][0].toString().trim();
            if (potentialSubject && !potentialSubject.match(/venue/i) && potentialSubject.length > 5) {
                 subject = potentialSubject.replace(/GR\s*10/i, '').trim();
            }
        }
        // --- END Subject Fix ---
        
        const venueCols = [];
        header.forEach((h, i) => { if (h.match(/venue/i)) venueCols.push(i); });

        const deskCols = [];
        header.forEach((h, i) => { if (h.match(/desk/i)) deskCols.push(i); });

        const dateCols = [];
        header.forEach((h, i) => {
          const hStr = h.toString().trim();
          if (hStr.match(/\d{1,2}[- \/](?:Oct|Nov|Dec|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep)/i)) {
            let paper = hStr.match(/P(\d)/) ? 'P' + RegExp.$1 : '';
            let dateStr = hStr.replace(/P\d/i, '').replace(/-/g, ' ').trim();
            dateCols.push({ col: i, paper, dateStr });
          }
        });

        let currentValues = new Array(header.length).fill('');
        
        // Start looping *after* the header row
        for (let r = headerRowIndex + 1; r < data.length; r++) {
          const row = data[r].map(cell => cell.toString().trim());

          // FIX: Skip only if BOTH potential name columns are empty
          if (!row[0] && !row[1]) continue;

          // Apply fill-down logic
          for (let c = 0; c < row.length; c++) {
            if (row[c] !== '') currentValues[c] = row[c];
          }

          // FIX: Check BOTH name columns
          // We check the *current row* for the name, not the fill-down.
          const nameCell1 = (row[0] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
          const nameCell2 = (row[1] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();

          let matched = false;
          for (const c of candidates) {
            if (nameCell1.includes(c) || nameCell2.includes(c)) {
              matched = true;
              break;
            }
          }

          if (!matched) continue; // Not the student we're looking for

          // --- Student matched. ---
          // FIX: Revert to the SIMPLE logic: Add all papers from the header.
          // This fixes the "insanely inaccurate" bug.
          for (const dateInfo of dateCols) {
            const dc = dateInfo.col;
            
            // Find the *last* "Venue" and "Desk" columns *before* this date column
            const vCol = venueCols.filter(v => v < dc).pop();
            const dCol = deskCols.filter(d => d < dc).pop();

            // Use the FILL-DOWN values for venue and desk
            let venue = (vCol !== undefined ? currentValues[vCol] : '') || 'N/A';
            let desk = (dCol !== undefined ? currentValues[dCol] : '') || 'N/A';
            
            // Handle layouts like "GR 10 CAT",Venue,"P1",Venue,Desk,"P2"
            // If venue/desk is blank, check for one *after* this paper column
            if (venue === 'N/A' || venue === '') {
                const vColAfter = venueCols.filter(v => v > dc && v < (dateInfo.col + 3)).shift(); 
                if (vColAfter !== undefined) {
                    venue = currentValues[vColAfter] || 'N/A';
                }
            }
            if (desk === 'N/A' || desk === '') {
                const dColAfter = deskCols.filter(d => d > dc && d < (dateInfo.col + 3)).shift();
                if (dColAfter !== undefined) {
                    desk = currentValues[dColAfter] || 'N/A';
                }
            }

            results.push({
              subject, // Subject is now clean
              paper: dateInfo.paper,
              dateStr: dateInfo.dateStr,
              venue: venue,
              desk: desk,
              sheet: sheetName
            });
          }
        }
      }
      return results;
    }


    /**
     * Fills in results with data from the timetableMap.
     */
    function enrichResultsWithTimetable(results) {
      return results.map(r => {
        const normalizedSubject = normalizeSubject(r.subject);
        const paper = (r.paper || 'P1').toLowerCase(); // Default to P1
        const key = `${normalizedSubject} ${paper}`;
        
        const ttEntry = timetableMap.get(key);

        if (ttEntry) {
          r.duration = ttEntry.duration;
          r.startTime = ttEntry.startTime;
          r.endTime = ttEntry.endTime;
        } else {
          // Fallback if not found
          r.duration = '2 hrs'; // Default
          r.startTime = '0900';
          r.endTime = '1100';
          console.warn(`No timetable entry found for key: "${key}" (Raw Subject: "${r.subject}", Paper: "${r.paper}")`);
        }
        return r;
      });
    }

    
    // --- UI & EVENT HANDLERS ---
    const runButton = document.getElementById('run');
    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');

    runButton.onclick = async () => {
      const q = (document.getElementById('query').value || '').trim();
      
      statusEl.textContent = '';
      resultsEl.innerHTML = '';
      runButton.disabled = true;

      if (!q) {
        statusEl.textContent = 'Please enter a name to search.';
        runButton.disabled = false;
        return;
      }

      const spinner = document.createElement('div');
      spinner.className = 'spinner';
      statusEl.appendChild(spinner);
      statusEl.appendChild(document.createTextNode(' Initializing...'));

      try {
        // 1. Generate Name Candidates
        const qNorm = q.toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
        const parts = qNorm.split(' ');
        let candidates = [];
        if (parts.length >= 2) {
          const first = parts[0];
          const last = parts.slice(1).join(' ');
          candidates.push((last + ' ' + first).toLowerCase(), (first + ' ' + last).toLowerCase(), (last + ', ' + first).toLowerCase(), (last + ',' + first).toLowerCase());
        } else {
          candidates.push(qNorm);
        }
        candidates = Array.from(new Set(candidates));

        // 2. Fetch and Parse Timetable
        if (timetableMap.size === 0) {
          statusEl.textContent = '';
          statusEl.appendChild(spinner);
          statusEl.appendChild(document.createTextNode(' Loading timetable...'));
          
          const ttAb = await fetchFile(fileBasePath + timetableFile);
          const ttWb = XLSX.read(ttAb, { type: 'array' });
          parseTimetable(ttWb);
        }

        // 3. Fetch and Parse Schedules
        statusEl.textContent = '';
        statusEl.appendChild(spinner);
        statusEl.appendChild(document.createTextNode(' Searching schedules... (0/' + scheduleFiles.length + ')'));

        let allResults = [];
        for (let i = 0; i < scheduleFiles.length; i++) {
          const fileName = scheduleFiles[i];
          statusEl.textContent = '';
          statusEl.appendChild(spinner);
          statusEl.appendChild(document.createTextNode(` Searching ${fileName}... (${i+1}/${scheduleFiles.length})`));
          
          try {
            const fileAb = await fetchFile(fileBasePath + fileName);
            const fileWb = XLSX.read(fileAb, { type: 'array' });
            const fileResults = parseSchedule(fileWb, candidates);
            allResults = allResults.concat(fileResults);
          } catch (fileError) {
            console.error(`Failed to load or parse ${fileName}:`, fileError);
            statusEl.textContent = `Error: Could not load ${fileName}. Skipping.`;
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }
        
        // 3.5 Remove duplicate results
        const uniqueResults = [];
        const seen = new Set();
        for (const r of allResults) {
            // A more unique key
            const key = `${r.subject}-${r.paper}-${r.dateStr}-${r.venue}-${r.desk}`;
            if (!seen.has(key)) {
                uniqueResults.push(r);
                seen.add(key);
            }
        }

        // 4. Process and Display Results
        statusEl.textContent = '';
        statusEl.appendChild(spinner);
        statusEl.appendChild(document.createTextNode(' Processing results...'));

        const finalResults = enrichResultsWithTimetable(uniqueResults);

        statusEl.textContent = `Found ${finalResults.length} match(es) for "${q}".`;

        if (finalResults.length === 0) {
          resultsEl.innerHTML = '<div class="text-gray-600">No matches found.</div>';
          runButton.disabled = false;
          return;
        }

        displayResultsTable(finalResults);

      } catch (error) {
        console.error('Main process error:', error);
        statusEl.textContent = `An error occurred: ${error.message}`;
      } finally {
        runButton.disabled = false;
        const spinnerEl = statusEl.querySelector('.spinner');
        if (spinnerEl) {
          statusEl.removeChild(spinnerEl);
        }
      }
    };

    /**
     * Renders the results table and "Add to Calendar" button.
     */
    function displayResultsTable(results) {
      const table = document.createElement('table');
      table.className = "min-w-full divide-y divide-gray-200 bg-white rounded-lg shadow-sm mt-4 border border-gray-200";
      const thead = document.createElement('thead');
      thead.className = "bg-gray-50";
      thead.innerHTML = `<tr>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Subject</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Paper</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Venue</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Desk</th>
      </tr>`;
      table.appendChild(thead);
      
      const tbody = document.createElement('tbody');
      tbody.className = "bg-white divide-y divide-gray-200";
      for (const r of results) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-800 font-medium">${r.subject.replace(/\n/g, ' ')}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.paper || '–'}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.dateStr}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.duration || 'N/A'}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.venue}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.desk}</td>
        `;
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      
      resultsEl.innerHTML = '';
      resultsEl.appendChild(table);

      const addBtn = document.createElement('button');
      addBtn.id = 'addCal';
      addBtn.textContent = 'Add All to Calendar';
      addBtn.className = "mt-6 px-5 py-2.5 bg-green-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500";
      resultsEl.appendChild(addBtn);

      addBtn.onclick = () => {
        generateICS(results);
      };
    }


    // --- CALENDAR .ICS GENERATION (FIXED & FULL-FEATURED) ---
    function getYYYYMMDD(dateObj) {
      const yyyy = dateObj.getFullYear();
      const mm = (dateObj.getMonth() + 1).toString().padStart(2, '0');
      const dd = dateObj.getDate().toString().padStart(2, '0');
      return `${yyyy}${mm}${dd}`;
    }

    function generateICS(results) {
      const events = [];
      const monthMap = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, sept: 8, oct: 9, nov: 10, dec: 11 };
      
      // Use 2025 as the year, based on timetable filename
      const year = 2025; 

      const vTimezone = [
        'BEGIN:VTIMEZONE',
        'TZID:Africa/Johannesburg',
        'BEGIN:STANDARD',
        'DTSTART:19700101T000000',
        'TZOFFSETFROM:+0200',
        'TZOFFSETTO:+0200',
        'TZNAME:SAST',
        'END:STANDARD',
        'END:VTIMEZONE'
      ].join('\n');

      for (const r of results) {
        try {
          const parts = r.dateStr.toLowerCase().split(/[\s\/]+/);
          const day = parseInt(parts[0], 10);
          const monStr = parts[1].slice(0, 3);
          const month = monthMap[monStr];
          
          if (isNaN(day) || month === undefined) {
            console.warn("Skipping event with invalid date string:", r.dateStr);
            continue;
          }
          
          const dateObj = new Date(year, month, day);
          const ymd = getYYYYMMDD(dateObj);
          
          const nextDay = new Date(dateObj.getTime() + 86400000);
          const ymdEnd = getYYYYMMDD(nextDay);
          
          const paperStr = r.paper ? `${r.paper} ` : '';
          const baseUid = `${r.subject.replace(/\s+/g, '')}-${r.paper || 'main'}-${ymd}@exam-schedule.com`;
          
          // --- Event 1: The Exam Paper (Timed Event) ---
          const title = `${r.subject.replace(/\n/g, ' ')} ${paperStr}(${r.duration || 'N/A'})`;
          const desc = `Venue: ${r.venue}\\nDesk: ${r.desk}`.replace(/,/g, '\\,');
          const location = r.venue.replace(/,/g, '\\,');
          
          events.push([
            'BEGIN:VEVENT',
            `UID:${baseUid}-exam`,
            `DTSTART;TZID=Africa/Johannesburg:${ymd}T${r.startTime || '0900'}00`,
            `DTEND;TZID=Africa/Johannesburg:${ymd}T${r.endTime || '1200'}00`,
            `SUMMARY:${title}`,
            `DESCRIPTION:${desc}`,
            `LOCATION:${location}`,
            'END:VEVENT'
          ].join('\n'));
          
          // --- Event 2: Venue/Desk Reminder (All-day Event) ---
          const venueTitle = `Venue: ${r.venue}, Desk: ${r.desk}`;
          const venueDesc = `For ${r.subject.replace(/\n/g, ' ')} ${paperStr}Exam`;
          
          events.push([
            'BEGIN:VEVENT',
            `UID:${baseUid}-venue`,
            `DTSTART;VALUE=DATE:${ymd}`,
            `DTEND;VALUE=DATE:${ymdEnd}`,
            `SUMMARY:${venueTitle}`,
            `DESCRIPTION:${venueDesc}`,
            `LOCATION:${location}`,
            'END:VEVENT'
          ].join('\n'));

        } catch (e) {
          console.warn("Could not parse event:", r, e);
        }
      }

      const ics = [
        'BEGIN:CALENDAR',
        'VERSION:2.0',
        'PRODID:-//YourApp//ExamScheduler//EN',
        vTimezone,
        ...events,
        'END:CALENDAR'
      ].join('\n');

      const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'exam_schedule.ics';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

  </script>
</body>
</html>


