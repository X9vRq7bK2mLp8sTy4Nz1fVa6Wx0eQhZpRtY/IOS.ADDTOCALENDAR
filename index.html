<!doctype html>
<html  lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exams</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial,-serif;
      overflow-x: hidden;
    }
    .spinner {
      border: 4px solid rgba(0, 0, 0, .1);
      border-left-color: #09f;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .table-container {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .past-exam, .block-day {
      color: #9ca3af !important;
    }
    .block-day td {
      font-style: italic;
      background-color: #f9fafb; /* Light gray background for block/weekend days */
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">

  <div class="max-w-4xl mx-auto bg-white p-6 md:p-8 rounded-lg shadow-md">
    <div class="flex justify-between items-center mb-2">
        <h3 class="text-2xl font-bold text-gray-900">Exam Schedules</h3>
        <p class="text-lg font-semibold text-blue-600">GR.10</p>
    </div>
    <div class="text-gray-600 text-sm mb-6">
      Enter a learner’s name to find all their subjects, dates, venues, and desks.
    </div>


    <label for="query" class="block text-sm font-medium text-gray-700 mt-4 mb-2">Search name</label>
    <input id="query" type="text" placeholder="e.g. Surname, Name or Name Surname"
           class="block w-full max-w-lg border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm p-2.5">

    <button id="run"
            class="mt-6 px-5 py-2.5 bg-blue-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400 flex items-center gap-2">
      Find Matches
    </button>
    
    <div id="status" class="text-gray-600 text-sm mt-4 flex items-center gap-2"></div>
    <div id="results" class="mt-6"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <script>
    const fileBasePath = '/resources/';
    const timetableFile = 'timetable.xlsx';
    const scheduleFiles = [
      'Acc.xlsx',
      'Afr-Drama.xlsx',
      'EGD-IT.xlsx',
      'LO.xlsx',
      'LS-VA.xlsx'
    ];
    const timetableMap = new Map();

    const subjectNormalizationMap = {
      'afri hl': 'afrikaans hl',
      'afri eat': 'afrikaans fal',
      'afri fal': 'afrikaans fal',
      'eng hl': 'english hl',
      'eng fal': 'english fal',
      'maths': 'mathematics',
      'maths lit': 'maths lit',
      'geo': 'geography',
      'it': 'it',
      'cat': 'cat',
      'life sciences': 'life sciences',
      'physical science': 'physical sc',
      'physical sc': 'physical sc',
      'business studies': 'business studies',
      'accounting': 'accounting',
      'history': 'history',
      'lo': 'life orientation',
      'design': 'design',
      'drama': 'dramatic arts',
      'dramatic arts': 'dramatic arts',
      'music': 'music',
      'visual arts': 'visual arts',
      'egd': 'egd',
      'isixhosa': 'isixhosa hl',
      'isixhosa hl': 'isixhosa hl'
    };

    function normalizeSubject(subject) {
      let norm = subject.toLowerCase()
        .replace(/gr\s*10/i,  '')
        .replace(/\n/g, ' ')
        .replace(/isixhosa/i, 'isiXhosa')
        .trim();
      
      if (norm.startsWith('physical sc')) return 'physical sc';
      if (norm.startsWith('afri eat')) return 'afrikaans fal';
      if (norm.startsWith('afri hl')) return 'afrikaans hl';
      if (norm.startsWith('eng hl')) return 'english hl';
      if (norm.startsWith('eng fal')) return 'english fal';
      
      return subjectNormalizationMap[norm] || norm;
    }

    async function fetchFile(url) {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Network error: ${response.statusText}`);
      return await response.arrayBuffer();
    }

    function parseTimetable(wb) {
      timetableMap.clear();
      for (const sheetName of wb.SheetNames) {
        const sheet = wb.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });
        if (data.length < 2) continue;

        let gr10ColIndex = -1;
        for (let r of [data[0], data[1]]) {
          if (r) {
            for (let i = 0; i < r.length; i++) {
              if (r[i].toString().trim().toLowerCase() === 'gr 10') {
                gr10ColIndex = i;
                break;
              }
            }
          }
          if (gr10ColIndex !== -1) break;
        }
        if (gr10ColIndex === -1) continue;

        for (let r = 2; r < data.length; r++) {
          const row = data[r];
          if (!row || !row[gr10ColIndex]) continue;
          const exams = row[gr10ColIndex].toString().split('\n');
          let currentSubject = '', currentPaper = '', currentDuration = '', currentStartTime = '', currentEndTime = '';

          for (const line of exams) {
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            const examMatch = trimmedLine.match(/^(.*?)\s*(P\d)?\s*\((.*?hrs?)\)$/i);
            const simpleExamMatch = trimmedLine.match(/^(.*?)\s*\((.*?hrs?)\)$/i);
            const timeMatch = trimmedLine.match(/(\d{2}):(\d{2})\s*[–-]\s*(\d{2}):(\d{2})/);

            if (examMatch) {
              currentSubject = examMatch[1].trim();
              currentPaper = (examMatch[2] || 'P1').trim();
              currentDuration = examMatch[3].trim().replace('hr', 'hrs');
            } else if (simpleExamMatch && !timeMatch && !currentSubject) {
              currentSubject = simpleExamMatch[1].trim();
              currentPaper = 'P1';
              currentDuration = simpleExamMatch[2].trim().replace('hr', 'hrs');
            } else if (timeMatch) {
              currentStartTime = `${timeMatch[1]}${timeMatch[2]}`;
              currentEndTime = `${timeMatch[3]}${timeMatch[4]}`;
            }

            if (currentSubject && currentPaper && currentDuration && currentStartTime) {
              const key = `${currentSubject.toLowerCase()} ${currentPaper.toLowerCase()}`;
              if (!timetableMap.has(key)) {
                timetableMap.set(key, {
                  duration: currentDuration,
                  startTime: currentStartTime,
                  endTime: currentEndTime
                });
              }
              currentSubject = ''; currentPaper = ''; currentDuration = ''; currentStartTime = ''; currentEndTime = '';
            }
          }
        }
      }
    }

    function parseSchedule(wb, candidates) {
      const results = [];
      for (const sheetName of wb.SheetNames) {
        const sheet = wb.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });
        if (data.length < 2) continue;

        let headerRowIndex = 0;
        let header = data[headerRowIndex].map(h => h.toString().trim());
        if (!header.some(h => h.match(/venue/i)) && data.length > 1) {
          const header2 = data[1].map(h => h.toString().trim());
          if (header2.some(h => h.match(/venue/i))) {
            headerRowIndex = 1;
            header = header2;
          }
        }

        let subject = (header[0] || '').replace(/GR\s*10/i, '').trim() || sheetName;
        const rawSubjectCell = data[headerRowIndex][0] ? data[headerRowIndex][0].toString() : '';
        if (rawSubjectCell.includes('\n')) {
          subject = rawSubjectCell.split('\n').join(' ').replace(/GR\s*10/i, '').trim();
        }
        if (headerRowIndex > 0) {
          let potentialSubject = data[0][0].toString().trim();
          if (potentialSubject && !potentialSubject.match(/venue/i) && potentialSubject.length > 5) {
            subject = potentialSubject.replace(/GR\s*10/i, '').trim();
          }
        }

        const venueCols = header.map((h, i) => h.match(/venue/i) ? i : -1).filter(i => i !== -1);
        const deskCols = header.map((h, i) => h.match(/desk/i) ? i : -1).filter(i => i !== -1);
        const dateCols = [];
        header.forEach((h, i) => {
          const hStr = h.toString().trim();
          if (hStr.match(/\d{1,2}[- \/](?:Oct|Nov|Dec)/i)) {
            let paper = hStr.match(/P(\d)/) ? 'P' + RegExp.$1 : '';
            let dateStr = hStr.replace(/P\d/i, '').replace(/-/g, ' ').trim();
            dateCols.push({ col: i, paper, dateStr });
          }
        });

        let currentValues = new Array(header.length).fill('');
        for (let r = headerRowIndex + 1; r < data.length; r++) {
          const row = data[r].map(cell => cell.toString().trim());
          if (!row[0] && !row[1]) continue;
          for (let c = 0; c < row.length; c++) {
            if (row[c] !== '') currentValues[c] = row[c];
          }

          const nameCell1 = (row[0] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
          const nameCell2 = (row[1] || '').toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
          let matched = candidates.some(c => nameCell1.includes(c) || nameCell2.includes(c));
          if (!matched) continue;

          for (const dateInfo of dateCols) {
            const dc = dateInfo.col;
            const vCol = venueCols.filter(v => v < dc).pop();
            const dCol = deskCols.filter(d => d < dc).pop();
            let venue = (vCol !== undefined ? currentValues[vCol] : '') || 'N/A';
            let desk = (dCol !== undefined ? currentValues[dCol] : '') || 'N/A';
            if (venue === 'N/A' || venue === '') {
              const vColAfter = venueCols.find(v => v > dc && v < dc + 3);
              if (vColAfter !== undefined) venue = currentValues[vColAfter] || 'N/A';
            }
            if (desk === 'N/A' || desk === '') {
              const dColAfter = deskCols.find(d => d > dc && d < dc + 3);
              if (dColAfter !== undefined) desk = currentValues[dColAfter] || 'N/A';
            }

            results.push({
              subject, paper: dateInfo.paper, dateStr: dateInfo.dateStr,
              venue, desk, sheet: sheetName
            });
          }
        }
      }
      return results;
    }

    function enrichResultsWithTimetable(results) {
      return results.map(r => {
        const key = `${normalizeSubject(r.subject)} ${(r.paper || 'P1').toLowerCase()}`;
        const tt = timetableMap.get(key);
        if (tt) {
          r.duration = tt.duration;
          r.startTime = tt.startTime;
          r.endTime = tt.endTime;
        } else {
          r.duration = '2 hrs';
          r.startTime = '0900';
          r.endTime = '1100';
        }
        return r;
      });
    }

    function addManualExams(results) {
      const hasDesign = results.some(r => normalizeSubject(r.subject) === 'design');
      const hasDrama = results.some(r => normalizeSubject(r.subject) === 'dramatic arts');
      const hasVA = results.some(r => normalizeSubject(r.subject) === 'visual arts');
      const manual = [];

      if (hasDesign) {
        manual.push({ subject: 'Design', paper: 'PRAC', dateStr: '14 Nov', duration: '6 hrs', startTime: '0800', endTime: '1400', venue: '-', desk: '-' });
        manual.push({ subject: 'Design', paper: 'PRAC', dateStr: '17 Nov', duration: '2 hrs', startTime: '1215', endTime: '1415', venue: '-', desk: '-' });
      }
      if (hasDrama) {
        manual.push({ subject: 'Dramatic Arts', paper: 'PRAC', dateStr: '20 Nov', duration: 'N/A', startTime: '1230', endTime: '1230', venue: '-', desk: '-' });
      }
      if (hasVA) {
        manual.push({ subject: 'Visual Arts', paper: 'PRAC', dateStr: '29 Oct', duration: '9 hrs', startTime: '0800', endTime: '1700', venue: '-', desk: '-' });
        manual.push({ subject: 'Visual Arts', paper: 'PRAC', dateStr: '20 Nov', duration: '9 hrs', startTime: '0800', endTime: '1700', venue: '-', desk: '-' });
      }

      return results.concat(manual);
    }

    /* ************************************
     * FIX: Block Day and Weekend Logic
     * ************************************/

    function parseDateStr(dateStr) {
      // Corrected month map: Oct is 9, Nov is 10, Dec is 11 (0-indexed)
      const months = { oct: 9, nov: 10, dec: 11 };
      const match = dateStr.match(/(\d{1,2})\s*(Oct|Nov|Dec)/i);
      if (!match) return null;
      const day = parseInt(match[1], 10);
      const month = months[match[2].toLowerCase()];
      // Set the year to 2025 as the context suggests
      return new Date(2025, month, day);
    }

    function addBlockDays(results) {
      if (results.length === 0) return results;

      // 1. Get all unique exam dates (from 27 Oct onwards)
      const examDates = results
        .map(r => parseDateStr(r.dateStr))
        .filter(d => d !== null && d.getTime() >= new Date(2025, 9, 27).getTime())
        .map(d => d.getTime()); // Use time value for easy comparison

      // Use a Set for fast lookup of exam days
      const examDateSet = new Set(examDates);

      if (examDateSet.size === 0) return results;
      
      const examDatesSorted = Array.from(examDateSet).sort((a, b) => a - b);

      // 2. Define the period to check
      const start = new Date(2025, 9, 27); // 27 Oct 2025
      const end = new Date(examDatesSorted[examDatesSorted.length - 1]); // Last exam date

      const blockDays = [];
      const monthNames = ['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      
      let current = new Date(start);
      // Loop from the start date up to and including the last exam date
      while (current.getTime() <= end.getTime()) {
        const ymd = `${current.getDate()} ${monthNames[current.getMonth() + 1]}`; // +1 because monthNames is 1-indexed
        const currentTime = current.getTime();
        const isExamDay = examDateSet.has(currentTime);
        const dayOfWeek = current.getDay(); // 0 = Sunday, 6 = Saturday

        if (!isExamDay) {
          // If it's a Saturday (6) or Sunday (0)
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            blockDays.push({
              subject: 'Weekend',
              paper: '-',
              dateStr: ymd,
              duration: '-',
              venue: '-',
              desk: '-',
              isBlock: true,
              isWeekend: true
            });
          } else {
            // Otherwise, it's a Block Day (weekday with no exam)
            blockDays.push({
              subject: 'Block Day',
              paper: '-',
              dateStr: ymd,
              duration: '-',
              venue: '-',
              desk: '-',
              isBlock: true,
              isWeekend: false
            });
          }
        }
        // Move to the next day
        current.setDate(current.getDate() + 1);
      }

      // 3. Concatenate and let sortByDate handle the final chronological order
      return results.concat(blockDays);
    }

    function sortByDate(results) {
      return results.sort((a, b) => {
        const da = parseDateStr(a.dateStr);
        const db = parseDateStr(b.dateStr);
        
        if (!da) return 1;
        if (!db) return -1;
        
        // Primary sort: Date
        const dateDiff = da.getTime() - db.getTime();
        if (dateDiff !== 0) return dateDiff;
        
        // Secondary sort: Ensure Block/Weekend days are not mixed with exams if their time parsing fails.
        // Since we only add block days on non-exam days, this simple date sort works perfectly.
        return 0;
      });
    }

    /* ************************************
     * END: FIX Block Day and Weekend Logic
     * ************************************/

    const runButton = document.getElementById('run');
    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');

    runButton.onclick = async () => {
      const q = (document.getElementById('query').value || '').trim();
      statusEl.textContent = '';
      resultsEl.innerHTML = '';
      runButton.disabled = true;

      if (!q) {
        statusEl.textContent = 'Please enter a name to search.';
        runButton.disabled = false;
        return;
      }

      const spinner = document.createElement('div');
      spinner.className = 'spinner';
      statusEl.appendChild(spinner);
      statusEl.appendChild(document.createTextNode(' Initializing...'));

      try {
        const qNorm = q.toLowerCase().replace(/[,\.]/g, '').replace(/\s+/g, ' ').trim();
        const parts = qNorm.split(' ');
        let candidates = [];
        if (parts.length >= 2) {
          const first = parts[0];
          const last = parts.slice(1).join(' ');
          candidates.push((last + ' ' + first).toLowerCase(), (first + ' ' + last).toLowerCase(), (last + ', ' + first).toLowerCase(), (last + ',' + first).toLowerCase());
        } else {
          candidates.push(qNorm);
        }
        candidates = Array.from(new Set(candidates));

        if (timetableMap.size === 0) {
          statusEl.textContent = ''; statusEl.appendChild(spinner); statusEl.appendChild(document.createTextNode(' Loading timetable...'));
          const ttAb = await fetchFile(fileBasePath + timetableFile);
          const ttWb = XLSX.read(ttAb, { type: 'array' });
          parseTimetable(ttWb);
        }

        statusEl.textContent = ''; statusEl.appendChild(spinner); statusEl.appendChild(document.createTextNode(' Searching schedules... (0/' + scheduleFiles.length + ')'));

        let allResults = [];
        for (let i = 0; i < scheduleFiles.length; i++) {
          const fileName = scheduleFiles[i];
          statusEl.textContent = ''; statusEl.appendChild(spinner); statusEl.appendChild(document.createTextNode(` Searching ${fileName}... (${i+1}/${scheduleFiles.length})`));
          try {
            const fileAb = await fetchFile(fileBasePath + fileName);
            const fileWb = XLSX.read(fileAb, { type: 'array' });
            const fileResults = parseSchedule(fileWb, candidates);
            allResults = allResults.concat(fileResults);
          } catch (e) {
            console.error(e);
          }
        }

        const uniqueResults = [];
        const seen = new Set();
        for (const r of allResults) {
          const key = `${r.subject}-${r.paper}-${r.dateStr}-${r.venue}-${r.desk}`;
          if (!seen.has(key)) { uniqueResults.push(r); seen.add(key); }
        }

        let finalResults = enrichResultsWithTimetable(uniqueResults);
        finalResults = addManualExams(finalResults);
        finalResults = addBlockDays(finalResults); // This now includes Weekends
        finalResults = sortByDate(finalResults);

        statusEl.textContent = `Found ${finalResults.filter(r => !r.isBlock).length} exam(s) for "${q}".`;
        if (finalResults.length === 0) {
          resultsEl.innerHTML = '<div class="text-gray-600">No matches found.</div>';
          runButton.disabled = false;
          return;
        }

        displayResultsTable(finalResults);

      } catch (error) {
        statusEl.textContent = `Error: ${error.message}`;
      } finally {
        runButton.disabled = false;
        const s = statusEl.querySelector('.spinner');
        if (s) statusEl.removeChild(s);
      }
    };

    function displayResultsTable(results) {
      const container = document.createElement('div');
      container.className = 'table-container';

      const table = document.createElement('table');
      table.className = "min-w-full divide-y divide-gray-200 bg-white rounded-lg shadow-sm mt-4 border border-gray-200";
      const thead = document.createElement('thead');
      thead.className = "bg-gray-50";
      thead.innerHTML = `<tr>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Subject</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Paper</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Venue</th>
        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Desk</th>
      </tr>`;
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      tbody.className = "bg-white divide-y divide-gray-200";

      const now = new Date(); now.setHours(0, 0, 0, 0);

      for (const r of results) {
        const tr = document.createElement('tr');
        const examDate = parseDateStr(r.dateStr);
        const isPast = examDate && examDate < now;
        const isBlock = r.isBlock;

        if (isPast) tr.classList.add('past-exam');
        if (isBlock) tr.classList.add('block-day');

        // Note: The isBlock flag is true for both 'Block Day' and 'Weekend' entries
        tr.innerHTML = `
          <td class="px-4 py-3 whitespace-nowrap text-sm font-medium ${isBlock ? 'text-gray-500' : 'text-gray-800'}">${r.subject}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${isBlock ? '–' : (r.paper || '–')}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${r.dateStr}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${isBlock ? '–' : (r.duration || 'N/A')}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${isBlock ? '–' : r.venue}</td>
          <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${isBlock ? '–' : r.desk}</td>
        `;
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      container.appendChild(table);
      resultsEl.innerHTML = '';
      resultsEl.appendChild(container);

      const addBtn = document.createElement('button');
      addBtn.id = 'addCal';
      addBtn.textContent = 'Add All to Calendar';
      addBtn.className = "mt-6 px-5 py-2.5 bg-blue-800 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-blue-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500";
      resultsEl.appendChild(addBtn);

      addBtn.onclick = () => generateICS(results.filter(r => !r.isBlock));
    }

    function getYYYYMMDD(d) {
      return `${d.getFullYear()}${(d.getMonth()+1).toString().padStart(2,'0')}${d.getDate().toString().padStart(2,'0')}`;
    }

    function generateICS(results) {
      const events = [];
      const year = 2025;
      const vTimezone = 'BEGIN:VTIMEZONE\nTZID:Africa/Johannesburg\nBEGIN:STANDARD\nDTSTART:19700101T000000\nTZOFFSETFROM:+0200\nTZOFFSETTO:+0200\nTZNAME:SAST\nEND:STANDARD\nEND:VTIMEZONE';

      for (const r of results) {
        const dateObj = parseDateStr(r.dateStr);
        if (!dateObj) continue;
        const ymd = getYYYYMMDD(dateObj);
        const next = new Date(dateObj.getTime() + 86400000);
        const ymdEnd = getYYYYMMDD(next);
        const paperStr = r.paper && r.paper !== '-' ? ` ${r.paper}` : '';
        const title = `${r.subject}${paperStr} (${r.duration || 'N/A'})`;
        const location = r.venue.replace(/,/g, '\\,');

        events.push(
          `BEGIN:VEVENT\nUID:${title.replace(/\s/g,'')}-${ymd}@exam-schedule.com-exam\nDTSTART;VALUE=DATE:${ymd}\nDTEND;VALUE=DATE:${ymdEnd}\nSUMMARY:${title}\nLOCATION:${location}\nEND:VEVENT`,
          `BEGIN:VEVENT\nUID:${title.replace(/\s/g,'')}-${ymd}@exam-schedule.com-venue\nDTSTART;VALUE=DATE:${ymd}\nDTEND;VALUE=DATE:${ymdEnd}\nSUMMARY:Class ${r.venue}, Desk ${r.desk}\nDESCRIPTION:For ${r.subject}${paperStr} exam\nLOCATION:${location}\nEND:VEVENT`
        );
      }

      const ics = `BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//ExamScheduler//EN\n${vTimezone}\n${events.join('\n')}\nEND:VCALENDAR`;
      const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'exam_schedule.ics'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
